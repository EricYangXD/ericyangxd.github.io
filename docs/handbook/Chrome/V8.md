---
title: 图解 Google V8
author: EricYangXD
date: "2022-01-13"
---

笔记

## V8 知识图谱

-   ![V8知识图谱](https://static001.geekbang.org/resource/image/90/43/90228d5cc0afbaaa4cca3fbdb1349243.jpg "V8知识图谱")
-   链接：https://static001.geekbang.org/resource/image/90/43/90228d5cc0afbaaa4cca3fbdb1349243.jpg

## V8 编译流水线

-   ![V8编译流水线](../../assets/V8pic.png "V8执行一段JavaScript流程图")

## 01 | V8 是如何执行一段 js 代码的

### 代码是怎么执行的：

1. 高级语言 ==输入==> 解析器 ==解析==> 中间代码 ==解释==> 解释器 ==执行==> 结果
2. 高级语言 ==输入==> 解析器 ==解析==> 中间代码 ==输入==> 编译器 ==编译==> 机器代码/CPU 指令集 ==执行==> 结果
    > 通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

### JavaScript 虚拟机/引擎

-   苹果公司在 Safari 中就是用 JavaScriptCore 虚拟机，Firefox 使用了 TraceMonkey 虚拟机，而 Chrome 则使用了 V8 虚拟机。
-   想知道如何安装 v8 的同学可以参考这个[链接](https://gist.github.com/kevincennis/0cd2138c78a07412ef21)：https://gist.github.com/kevincennis/0cd2138c78a07412ef21

### V8

-   V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。
-   ![V8编译流水线](../../assets/V8pic.png "V8执行一段JavaScript流程图")
-   如上图，在解释器附近的监控机器人是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。当某段代码被标记为热点代码后，V8 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。
-   如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。
-   不过，和静态语言不同的是，JavaScript 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过**反优化**的代码，下次执行时就会回退到解释器解释执行。

主要流程如下：

1. 初始化基础环境；
2. 解析源码生成 AST 和作用域；
3. 依据 AST 和作用域生成字节码；
4. 解释执行字节码；
5. 监听热点代码；
6. 优化热点代码为二进制的机器代码；
7. 反优化生成的二进制机器代码。

### 作用域和上下文

-   执行上下文是运行代码时的基础环境，包括了变量环境，词法环境，this 值，外部环境等内容。
-   全局执行上下文就是指全局代码执行时的运行环境。
-   而作用域是一个抽象概念，它主要引用了执行上下文中的变量，以方便查找。

## 02 | 函数即对象

-   在 js 中，函数是一种特殊的对象，是可以被赋值、作为参数，还可以作为返回值的，那么如果一个函数返回了另外一个函数，那么就应该返回该函数所有相关的内容。
-   函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性，分别是 name 属性和 code 属性。
-   隐藏 name 属性的值就是函数名称，如果某个函数没有设置函数名，该函数对象的默认的 name 属性值就是 anonymous，表示该函数对象没有被设置名称。
-   另外一个隐藏属性是 code 属性，其值表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码。
-   函数还有另外一个隐藏属性，那就是 prototype。
-   一个函数到底关联了哪些内容：
    -   函数作为一个对象，它有自己的属性和值，所以函数关联了基础的属性和值；
    -   函数之所以成为特殊的对象，这个特殊的地方是函数可以“被调用”，所以一个函数被调用时，它还需要关联相关的执行上下文。

## 03 | 快属性和慢属性

### 常规属性 (properties) 和排序属性 (element)

-   在 ECMAScript 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。
-   我们把对象中的数字属性称为排序属性，在 V8 中被称为 elements，字符串属性就被称为常规属性，在 V8 中被称为 properties。
-   在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。
-   也就是说，在 V8 内部，一个对象会自动包含两个隐藏属性：elements 属性和 properties 属性，elements 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存了常规属性。
-   分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。

### 快属性和慢属性

1.  线性结构：数组、栈、队列等；非线性结构：树、字典-hash 表等。
2.  将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，因此会影响到元素的查找效率。
3.  基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为**对象内属性 (in-object properties)**。
4.  对象内属性的数量是固定的，默认是 10 个，超过了则会被保存在常规属性存储中。
5.  将保存在线性数据结构中的属性称之为**快属性**，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。
6.  一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是**慢属性**策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。
7.  除了 elements 和 properties 属性，V8 还为每个对象实现了 map 属性和 **\_\_proto\_\_** 属性，以及隐藏类（Hidden Class）。其中，隐藏类用于描述对象的结构。
8.  几个问题：

-   element 没有内置。
    -   element 默认应该采用连续的存储结构，通过浪费空间换取时间，直接下标访问，提升访问速度。
    -   但当 element 的序号十分不连续时，会优化成为 hash 表，因为要浪费的空间太大了，不合算。
-   property 默认采用链表结构
    -   当数据量很小时，查找也会很快，但数据量上升到某个数值后，会优化成为 hash 表。
    -   因为超过某个数值，顺序查找就不够快了，需要通过 hash 表结构查找，提升速度。
-   hash 表不是应该查找一次吗？为何是慢查询？
    -   hash 表要解决 key 冲突问题，一般会用 list 存储多个冲突的 key，所以计算 hash 后，还是要做顺序访问，所以要多次访问。
    -   此外，还涉及到 hash 扩容的问题，那就更慢了。
    -   所以，整体上来说，hash 慢于按地址访问的；
    -   在数据量小的时候，也慢于链表的顺序访问。
-   hash 表如何存储 property 顺序？
    -   再用一个链表记录插入属性就好了，类似于 Java 中的 LinkedHashMap ，就可以解决问题

## 04 | 函数表达式

### 函数声明

-   在编译阶段，将所有的变量提升到作用域的过程称为变量提升。
-   如果是一个普通变量，变量提升之后的值都是 undefined，如果是声明的函数，那么变量提升之后的值则是函数对象。
-   var x 是在编译阶段完成的，也可以说是在变量提升阶段完成的，而 x = 5 是表达式，所有的表达式都是在执行阶段完成的。
-   所以表达式是不会在编译阶段执行的。
-   在变量提升阶段，V8 将这些变量存放在作用域时，还会给它们赋一个默认的 undefined 值
-   函数声明并不是一个表达式，而是一个语句。V8 在变量提升阶段，如果遇到函数声明，那么 V8 同样会对该函数声明执行变量提升操作。
-   函数也是一个对象，所以在编译阶段，V8 就会将整个函数对象提升到作用域中，而不是给该函数名称赋一个 undefined。

#### 总结：

-   在 V8 解析 JavaScript 源码的过程中，如果遇到普通的变量声明，那么便会将其提升到作用域中，并给该变量赋值为 undefined，如果遇到的是函数声明，那么 V8 会在内存中为声明生成函数对象，并将该对象提升到作用域中。

### 函数表达式

-   因为函数立即表达式也是一个表达式，所以 V8 在编译阶段，并不会为该表达式创建函数对象。这样的一个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到。

## 05 | 原型链

### 继承

-   继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。
-   最典型的两种方式是基于类的设计和基于原型继承的设计。
-   不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的。
-   在实际项目中，我们不应该直接通过 \_\_proto\_\_ 来访问或者修改该属性，其主要原因有两个：首先，这是隐藏属性，并不是标准定义的 ;其次，使用该属性会造成严重的性能问题。
-   每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性。
-   参考[文章](https://juejin.cn/post/6844903837623386126)

## 06 | 作用域链

-   **作用域**就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。
-   **作用域链**就是将一个个作用域串起来，实现变量查找的路径。
-   作用域链是基于调用栈的，而不是基于函数定义的位置的。
-   因为 JavaScript 是基于**词法作用域**的，词法作用域就是指，**查找作用域的顺序是按照函数定义时的位置来决定的**。也就是说函数的作用域在函数声明时就已经确定了，除非使用 call/apply/bind 等改变它的 this 指向。
-   因为词法作用域是根据函数在代码中的位置来确定的，作用域是在声明函数时就确定好的了，所以我们也将词法作用域称为静态作用域。

## 07 | 类型转换

### a+b

V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：

1. 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换；
2. 如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值；
3. 如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误；
4. toPrimitive 的第二个参数期望值，如果没填默认值是 Number，但是 date 类型的默认值是 String。Number 就是 valueOf 先调用,String 就是 toString 先调用。
    > 综上：可以通过重写对象的 valueOf 和 toString 方法来实现一些骚操作

## 08 | 如何构建和使用 V8 的调试工具 d8
