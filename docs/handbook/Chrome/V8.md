---
title: 图解 Google V8
author: EricYangXD
date: "2022-01-13"
---

笔记

## V8 知识图谱

-   ![V8知识图谱](https://static001.geekbang.org/resource/image/90/43/90228d5cc0afbaaa4cca3fbdb1349243.jpg "V8知识图谱")
-   链接：https://static001.geekbang.org/resource/image/90/43/90228d5cc0afbaaa4cca3fbdb1349243.jpg

## V8 编译流水线

-   ![V8编译流水线](../../assets/V8pic.png "V8执行一段JavaScript流程图")

## 01 | V8 是如何执行一段 js 代码的

### 代码是怎么执行的：

1. 高级语言 ==输入==> 解析器 ==解析==> 中间代码 ==解释==> 解释器 ==执行==> 结果
2. 高级语言 ==输入==> 解析器 ==解析==> 中间代码 ==输入==> 编译器 ==编译==> 机器代码/CPU 指令集 ==执行==> 结果
    > 通常编译成的机器代码是以二进制文件形式存储的，需要执行这段程序的时候直接执行二进制文件就可以了。还可以使用虚拟机将编译后的机器代码保存在内存中，然后直接执行内存中的二进制代码。

### JavaScript 虚拟机/引擎

-   苹果公司在 Safari 中就是用 JavaScriptCore 虚拟机，Firefox 使用了 TraceMonkey 虚拟机，而 Chrome 则使用了 V8 虚拟机。
-   想知道如何安装 v8 的同学可以参考这个[链接](https://gist.github.com/kevincennis/0cd2138c78a07412ef21)：https://gist.github.com/kevincennis/0cd2138c78a07412ef21

### V8

-   V8 并没有采用某种单一的技术，而是混合编译执行和解释执行这两种手段，我们把这种混合使用编译器和解释器的技术称为 JIT（Just In Time）技术。
-   ![V8编译流水线](../../assets/V8pic.png "V8执行一段JavaScript流程图")
-   如上图，在解释器附近的监控机器人是一个监控解释器执行状态的模块，在解释执行字节码的过程中，如果发现了某一段代码会被重复多次执行，那么监控机器人就会将这段代码标记为热点代码。当某段代码被标记为热点代码后，V8 就会将这段字节码丢给优化编译器，优化编译器会在后台将字节码编译为二进制代码，然后再对编译后的二进制代码执行优化操作，优化后的二进制机器代码的执行效率会得到大幅提升。
-   如果下面再执行到这段代码时，那么 V8 会优先选择优化之后的二进制代码，这样代码的执行速度就会大幅提升。
-   不过，和静态语言不同的是，JavaScript 是一种非常灵活的动态语言，对象的结构和属性是可以在运行时任意修改的，而经过优化编译器优化过的代码只能针对某种固定的结构，一旦在执行过程中，对象的结构被动态修改了，那么优化之后的代码势必会变成无效的代码，这时候优化编译器就需要执行反优化操作，经过**反优化**的代码，下次执行时就会回退到解释器解释执行。

主要流程如下：

1. 初始化基础环境；
2. 解析源码生成 AST 和作用域；
3. 依据 AST 和作用域生成字节码；
4. 解释执行字节码；
5. 监听热点代码；
6. 优化热点代码为二进制的机器代码；
7. 反优化生成的二进制机器代码。

### 作用域和上下文

-   执行上下文是运行代码时的基础环境，包括了变量环境，词法环境，this 值，外部环境等内容。
-   全局执行上下文就是指全局代码执行时的运行环境。
-   而作用域是一个抽象概念，它主要引用了执行上下文中的变量，以方便查找。

## 02 | 函数即对象

-   在 js 中，函数是一种特殊的对象，是可以被赋值、作为参数，还可以作为返回值的，那么如果一个函数返回了另外一个函数，那么就应该返回该函数所有相关的内容。
-   函数除了可以拥有常用类型的属性值之外，还拥有两个隐藏属性，分别是 name 属性和 code 属性。
-   隐藏 name 属性的值就是函数名称，如果某个函数没有设置函数名，该函数对象的默认的 name 属性值就是 anonymous，表示该函数对象没有被设置名称。
-   另外一个隐藏属性是 code 属性，其值表示函数代码，以字符串的形式存储在内存中。当执行到一个函数调用语句时，V8 便会从函数对象中取出 code 属性值，也就是函数代码，然后再解释执行这段函数代码。
-   函数还有另外一个隐藏属性，那就是 prototype。
-   一个函数到底关联了哪些内容：
    -   函数作为一个对象，它有自己的属性和值，所以函数关联了基础的属性和值；
    -   函数之所以成为特殊的对象，这个特殊的地方是函数可以“被调用”，所以一个函数被调用时，它还需要关联相关的执行上下文。

## 03 | 快属性和慢属性

### 常规属性 (properties) 和排序属性 (element)

-   在 ECMAScript 规范中定义了数字属性应该按照索引值大小升序排列，字符串属性根据创建时的顺序升序排列。
-   我们把对象中的数字属性称为排序属性，在 V8 中被称为 elements，字符串属性就被称为常规属性，在 V8 中被称为 properties。
-   在 V8 内部，为了有效地提升存储和访问这两种属性的性能，分别使用了两个线性数据结构来分别保存排序属性和常规属性。
-   也就是说，在 V8 内部，一个对象会自动包含两个隐藏属性：elements 属性和 properties 属性，elements 属性指向了 elements 对象，在 elements 对象中，会按照顺序存放排序属性，properties 属性则指向了 properties 对象，在 properties 对象中，会按照创建时的顺序保存了常规属性。
-   分解成这两种线性数据结构之后，如果执行索引操作，那么 V8 会先从 elements 属性中按照顺序读取所有的元素，然后再在 properties 属性中读取所有的元素，这样就完成一次索引操作。

### 快属性和慢属性

1.  线性结构：数组、栈、队列等；非线性结构：树、字典-hash 表等。
2.  将不同的属性分别保存到 elements 属性和 properties 属性中，无疑简化了程序的复杂度，但是在查找元素时，却多了一步操作，因此会影响到元素的查找效率。
3.  基于这个原因，V8 采取了一个权衡的策略以加快查找属性的效率，这个策略是将部分常规属性直接存储到对象本身，我们把这称为**对象内属性 (in-object properties)**。
4.  对象内属性的数量是固定的，默认是 10 个，超过了则会被保存在常规属性存储中。
5.  将保存在线性数据结构中的属性称之为**快属性**，因为线性数据结构中只需要通过索引即可以访问到属性，虽然访问线性结构的速度快，但是如果从线性结构中添加或者删除大量的属性时，则执行效率会非常低，这主要因为会产生大量时间和内存开销。
6.  一个对象的属性过多时，V8 就会采取另外一种存储策略，那就是**慢属性**策略，但慢属性的对象内部会有独立的非线性数据结构 (词典) 作为属性存储容器。所有的属性元信息不再是线性存储的，而是直接保存在属性字典中。
7.  除了 elements 和 properties 属性，V8 还为每个对象实现了 map 属性和 **\_\_proto\_\_** 属性，以及隐藏类（Hidden Class）。其中，隐藏类用于描述对象的结构。
8.  几个问题：

-   element 没有内置。
    -   element 默认应该采用连续的存储结构，通过浪费空间换取时间，直接下标访问，提升访问速度。
    -   但当 element 的序号十分不连续时，会优化成为 hash 表，因为要浪费的空间太大了，不合算。
-   property 默认采用链表结构
    -   当数据量很小时，查找也会很快，但数据量上升到某个数值后，会优化成为 hash 表。
    -   因为超过某个数值，顺序查找就不够快了，需要通过 hash 表结构查找，提升速度。
-   hash 表不是应该查找一次吗？为何是慢查询？
    -   hash 表要解决 key 冲突问题，一般会用 list 存储多个冲突的 key，所以计算 hash 后，还是要做顺序访问，所以要多次访问。
    -   此外，还涉及到 hash 扩容的问题，那就更慢了。
    -   所以，整体上来说，hash 慢于按地址访问的；
    -   在数据量小的时候，也慢于链表的顺序访问。
-   hash 表如何存储 property 顺序？
    -   再用一个链表记录插入属性就好了，类似于 Java 中的 LinkedHashMap ，就可以解决问题

## 04 | 函数表达式

### 函数声明

-   在编译阶段，将所有的变量提升到作用域的过程称为变量提升。
-   如果是一个普通变量，变量提升之后的值都是 undefined，如果是声明的函数，那么变量提升之后的值则是函数对象。
-   var x 是在编译阶段完成的，也可以说是在变量提升阶段完成的，而 x = 5 是表达式，所有的表达式都是在执行阶段完成的。
-   所以表达式是不会在编译阶段执行的。
-   在变量提升阶段，V8 将这些变量存放在作用域时，还会给它们赋一个默认的 undefined 值
-   函数声明并不是一个表达式，而是一个语句。V8 在变量提升阶段，如果遇到函数声明，那么 V8 同样会对该函数声明执行变量提升操作。
-   函数也是一个对象，所以在编译阶段，V8 就会将整个函数对象提升到作用域中，而不是给该函数名称赋一个 undefined。

#### 总结：

-   在 V8 解析 JavaScript 源码的过程中，如果遇到普通的变量声明，那么便会将其提升到作用域中，并给该变量赋值为 undefined，如果遇到的是函数声明，那么 V8 会在内存中为声明生成函数对象，并将该对象提升到作用域中。

### 函数表达式

-   因为函数立即表达式也是一个表达式，所以 V8 在编译阶段，并不会为该表达式创建函数对象。这样的一个好处就是不会污染环境，函数和函数内部的变量都不会被其他部分的代码访问到。

## 05 | 原型链

### 继承

-   继承就是一个对象可以访问另外一个对象中的属性和方法，在 JavaScript 中，我们通过原型和原型链的方式来实现了继承特性。
-   最典型的两种方式是基于类的设计和基于原型继承的设计。
-   不要将原型链接和作用域链搞混淆了，作用域链是沿着函数的作用域一级一级来查找变量的，而原型链是沿着对象的原型一级一级来查找属性的，虽然它们的实现方式是类似的，但是它们的用途是不同的。
-   在实际项目中，我们不应该直接通过 \_\_proto\_\_ 来访问或者修改该属性，其主要原因有两个：首先，这是隐藏属性，并不是标准定义的 ;其次，使用该属性会造成严重的性能问题。
-   每个函数对象中都有一个公开的 prototype 属性，当你将这个函数作为构造函数来创建一个新的对象时，新创建对象的原型对象就指向了该函数的 prototype 属性。
-   参考[文章](https://juejin.cn/post/6844903837623386126)

## 06 | 作用域链

-   **作用域**就是存放变量和函数的地方，全局环境有全局作用域，全局作用域中存放了全局变量和全局函数。每个函数也有自己的作用域，函数作用域中存放了函数中定义的变量。
-   **作用域链**就是将一个个作用域串起来，实现变量查找的路径。
-   作用域链是基于调用栈的，而不是基于函数定义的位置的。
-   因为 JavaScript 是基于**词法作用域**的，词法作用域就是指，**查找作用域的顺序是按照函数定义时的位置来决定的**。也就是说函数的作用域在函数声明时就已经确定了，除非使用 call/apply/bind 等改变它的 this 指向。
-   因为词法作用域是根据函数在代码中的位置来确定的，作用域是在声明函数时就确定好的了，所以我们也将词法作用域称为静态作用域。

## 07 | 类型转换

### a+b

V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：

1. 先检测该对象中是否存在 valueOf 方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换；
2. 如果 valueOf 没有返回原始类型，那么就使用 toString 方法的返回值；
3. 如果 vauleOf 和 toString 两个方法都不返回基本类型值，便会触发一个 TypeError 的错误；
4. toPrimitive 的第二个参数期望值，如果没填默认值是 Number，但是 date 类型的默认值是 String。Number 就是 valueOf 先调用,String 就是 toString 先调用。
    > 综上：可以通过重写对象的 valueOf 和 toString 方法来实现一些骚操作

## 08 | 如何构建和使用 V8 的调试工具 d8

过...

## 09 | 运行时环境

在执行 JavaScript 代码之前，V8 就已经准备好了代码的运行时环境，这个环境包括了堆空间和栈空间、全局执行上下文、全局作用域、内置的内建函数、宿主环境提供的扩展函数和对象，还有消息循环系统。准备好运行时环境之后，V8 才可以执行 JavaScript 代码，这包括解析源码、生成字节码、解释执行或者编译执行这一系列操作。V8 自身会提供 JavaScript 的核心功能和垃圾回收系统。

除了浏览器可以作为 V8 的宿主环境，Node.js 也是 V8 的另外一种宿主环境，它提供了不同的宿主对象和宿主的 API，但是整个流程依然是相同的。

在 Chrome 中，只要打开一个渲染进程，渲染进程便会初始化 V8，同时初始化堆空间和栈空间，因为是一个进程内部的，所以宿主和 v8 共用一套内存空间。

栈空间主要是用来管理 JavaScript 函数调用的，栈是内存中连续的一块空间，同时栈结构是“先进后出”的策略。在函数调用过程中，涉及到上下文相关的内容都会存放在栈上，比如原生类型、引用到的对象的地址、函数的执行状态、this 值等都会存在在栈上，读取速度快。当一个函数执行结束，那么该函数的执行上下文便会被销毁掉。

堆空间是一种树形的存储结构，用来存储对象类型的离散的数据：一些占用内存比较大的数据，或者不需要存储在连续空间中的数据，读取速度慢。

执行上下文中主要包含三部分，变量环境、词法环境和 this 关键字。比如在浏览器的环境中，全局执行上下文中就包括了 window 对象，还有默认指向 window 的 this 关键字，另外还有一些 Web API 函数，诸如 setTimeout、XMLHttpRequest 等内容。而词法环境中，则包含了使用 let、const 等变量的内容。

全局执行上下文在 V8 的生存周期内是不会被销毁的，它会一直保存在堆中，这样当下次在需要使用函数或者全局变量时，就不需要重新创建了。

V8 还需要有一个主线程，用来执行 JavaScript 和执行垃圾回收等工作。V8 是寄生在宿主环境中的，它并没有自己的主线程，而是使用宿主所提供的主线程，V8 所执行的代码都是在宿主的主线程上执行的。

为了在执行完代码之后，让线程继续运行，通常的做法是在代码中添加一个循环语句，在循环语句中监听下个事件，即事件循环。如果没有任务，那么该线程将被挂起，一旦有新的任务到达了消息队列，那么系统会将这个挂起的线程激活，激活之后线程继续向下执行，并不会导致卡死。

## 10 | 机器代码

在执行代码时，V8 需要先将 JavaScript 编译成字节码，然后再解释执行字节码，或者将需要优化的字节码编译成二进制，并直接执行二进制代码。

代码经过编译之后生成二进制代码/机器码，实质就是一堆指令按照顺序集合在一起组成程序，所以程序的执行，本质上就是 CPU 按顺序执行这一大堆指令的过程。

-   [计算机系统的硬件组织结构](../../assets/pchard.png "计算机系统的硬件组织结构")

我们把取出指令、分析指令、执行指令这三个过程称为一个 CPU 时钟周期。

在执行指令的过程中，CPU 需要对数据执行读写操作，如果直接读写内存，那么会严重影响程序的执行性能，因此 CPU 就引入了寄存器，将一些**中间数据**存放在寄存器中，这样就能加速 CPU 的执行速度。

通用寄存器容量小，读写速度快，内存容量大，读写速度慢。

rbp 寄存器通常是用来存放栈帧指针的，rsp 寄存器用来存放栈顶指针的，PC 寄存器用来存放下一条要执行的指令等。

几种常用的指令类型：

-   加载的指令，其作用是从内存中复制指定长度的内容到通用寄存器中，并覆盖寄存器中原来的内容。
-   存储的指令，和加载类型的指令相反，其作用是将寄存器中的内容复制内存某个位置，并覆盖掉内存中的这个位置上原来的内容。
-   更新指令，其作用是复制两个寄存器中的内容到 ALU 中，也可以是一块寄存器和一块内存中的内容到 ALU 中，ALU 将两个字相加，并将结果存放在其中的一个寄存器中，并覆盖该寄存器中的内容。
-   跳转指令，从指令本身抽取出一个值，这个值是下一条要执行的指令的地址，并将该字复制到 PC 寄存器中，并覆盖掉 PC 寄存器中原来的值。那么当执行下一条指令时，便会跳转到对应的指令了。
-   IO 读 / 写指令，这些指令可以从一个 IO 设备中复制指定长度的数据到寄存器中，也可以将一个寄存器中的数据复制到指定的 IO 设备。

CPU 执行程序的过程：

1. 首先，在程序执行之前，我们的程序需要被装进内存；
2. CPU 从 PC 寄存器中拿到要执行的指令地址，并从内存中取出指令；
3. 此时，系统会做两件事：1.是将下一条指令的地址更新到 PC 寄存器中；2.是分析取出的该指令，并识别出不同的类型的指令，以及各种获取操作数的方法；
4. 然后执行该指令——通过加载、更新、存储、跳过等指令执行。这期间需要寄存器和内存之间传输数据，或者寄存器和寄存器之间传输数据。

## 11 | 堆和栈

### 为什么使用栈结构来管理函数调用？

1. 第一个特点是函数可以被调用
2. 第二个特点是函数具有作用域机制
3. 函数调用者的生命周期总是长于被调用者（后进），并且被调用者的生命周期总是先于调用者的生命周期结束 (先出)。
4. 站在函数资源分配和回收角度来看，被调用函数的资源分配总是晚于调用函数 (后进)，而函数资源的释放则总是先于调用函数 (先出)。
5. 函数的生命周期和函数的资源分配情况符合后进先出 (LIFO) 的策略，而栈结构正好满足这种后进先出 (LIFO) 的需求，所以我们选择栈来管理函数调用关系是一种很自然的选择。

### 恢复现场

函数 B 执行完成之后，需要将执行代码的控制权转交给 A 函数，这意味着需要将栈的状态恢复到 A 函数上次执行时的状态，我们把这个过程叫恢复现场。

在 esp 寄存器中存放一个永远指向当前栈顶的指针，栈顶指针的作用就是告诉你应该往哪个位置添加新元素。增减元素之后要将新元素的地址更新到 esp 寄存器中。

CPU 的解决方法是增加了另外一个 ebp 寄存器，用来保存当前函数的起始位置，我们把一个函数的起始位置也称为栈帧指针，ebp 寄存器中保存的就是当前函数的栈帧指针。

栈帧的概念：每个栈帧对应着一个未运行完的函数，栈帧中保存了该函数的返回地址和局部变量。

## 12 | 延迟解析：V8 是如何实现闭包的？

惰性解析是指解析器在解析的过程中，如果遇到函数声明，那么会跳过函数内部的代码，并不会为其生成 AST 和字节码，而仅仅生成顶层代码的 AST 和字节码。利用惰性解析可以加速 JavaScript 代码的启动速度，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间。

和 JavaScript 闭包相关的三个重要特性：

1. 可以在 JavaScript 函数内部定义新的函数；
2. 内部函数中访问父函数中定义的变量；
3. 因为 JavaScript 中的函数是一等公民，所以函数可以作为另外一个函数的返回值。

V8 在执行 foo 父函数时需要判断 inner 子函数是否引用了 foo 函数中的变量，负责处理这个任务的模块叫做预解析器。

遇到一个函数，预解析器并不会直接跳过该函数，而是对该函数做一次快速的预解析：一是判断当前函数是不是存在一些语法上的错误；二是检查函数内部是否引用了外部变量，**如果引用了外部的变量，预解析器会将栈中的变量复制到堆中**，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

## 13 |

## 14 |

## 15 |

## 16 |

## 17 |

## 18 |

## 19 |

## 20 |

## 21 |

## 22 |
