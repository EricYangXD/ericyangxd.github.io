---
title: Http协议
author: EricYangXD
date: "2022-01-04"
---

## HTTP 协议

HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。

在互联网世界里，HTTP 通常跑在 TCP/IP 协议栈之上，依靠 IP 协议实现寻址和路由、TCP 协议实现可靠数据传输、DNS 协议实现域名查找、SSL/TLS 协议实现安全通信。此外，还有一些协议依赖于 HTTP，例如 WebSocket、HTTPDNS 等。这些协议相互交织，构成了一个协议网，而 HTTP 则处于中心地位。

### http 请求构成

-   http: 请求行 + 头部信息 + 空白行 + body。
-   tcp: tcp 头（至少 20 字节）+实际传输的数据（通常 1460 字节）。
-   空白行的意义：按照 http 协议，空白行就是为了分隔 header 和 body，因为 http 是纯文本的协议。

### http 常用头字段

HTTP 协议规定了非常多的头部字段，实现各种各样的功能，但基本上可以分为四大类：

1. 通用字段：在请求头和响应头里都可以出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

### Methods

在 HTTP 协议里，所谓的“安全”是指请求方法不会“破坏”服务器上的资源，即不会对服务器上的资源造成实质的修改。

HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。

| 方法 Method | 幂等 Idempotent | 安全 Safe | 可缓存 Cacheable                                           |
| ----------- | --------------- | --------- | ---------------------------------------------------------- |
| HEAD        | Y               | Y         | Y                                                          |
| OPTIONS     | Y               | Y         | N                                                          |
| GET         | Y               | Y         | Y                                                          |
| PUT         | Y               | N         | N                                                          |
| DELETE      | Y               | N         | N                                                          |
| TRACE       | Y               | Y         | N                                                          |
| POST        | N               | N         | Only if freshness information is included 包含新鲜度信息时 |
| PATCH       | N               | N         | N                                                          |
| CONNECT     | N               | N         | N                                                          |

### 幂等

-   Q: 什么是幂等性?
-   A: 简单来说就是一个操作无论执行多少次，都会得到相同的结果，即 f(x)=f(f(x))。
-   GET 和 HEAD 方法，它们是“只读”操作，很显然，GET 和 HEAD 既是安全的也是幂等的。
-   DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。
-   POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的。
-   PUT 是“替换或更新数据”，多次更新一个资源，资源还是第一次更新的状态，所以是幂等的。

### OPTIONS 方法

跨域资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），浏览器必须首先使用 **OPTIONS** 方法发起一个**预检请求（preflight request）**，从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。在现在前端最常用的 CORS 跨域中，浏览器都是用 **OPTIONS** 方法发预检请求的。

### PATCH 和 PUT 方法的区别

1. PATCH 方法是新引入的，是对 PUT 方法的补充，用来对已知资源进行局部更新;
2. PATCH 请求中的实体是一组将要应用到实体的更改，而不是像 PUT 请求那样是要替换旧资源的实体;
3. PATCH 只传要更新的字段到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段;
4. PUT 虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象;
5. PUT 是幂等的，而 PATCH 不一定是幂等的;
6. PUT 更新整个资源，即整个集合，所以 PUT 是幂等的;
7. PATCH 请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改，所以不是幂等的，也就是，通过使用 PATCH，新资源可能被创造，或者现有资源被修改。
8. POST 方法一定不是幂等的；多次执行同样的操作，每一次都会创建一个相同的新资源。

### 杂记

1. 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。
2. HTTP 本质是无状态的，使用 Cookies 可以创建有状态的会话。
3. 实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器、操作系统对它的限制。同理，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制。
4. 还会包括「代理」的因素在里面，可能 url 太长还没到服务，就已经被代理拒绝掉了。
5. 一般浏览器对 URL 长度的最大限制从 2083 个字符（IE)到 19 万个字符（Opera)不等，Chrome-8182 个字符，Apache (Server)-8192 个字符，Firefox-65536 个字符，等等。
6. 一般，URL 如果包含汉字，会进行转换 encodeURIComponent，如果浏览器的编码为 UTF8 的话，一个汉字最终编码后的字符长度为 9 个字符。因此如果使用的 GET 方法，最大长度等于 URL 最大长度减去实际路径中的字符数。

### GET VS POST：

1. 多数浏览器对于 POST 采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于 GET），也就是第一步发送 header 数据，第二步再发送 body 部分。HTTP 是应用层的协议，而在传输层有些情况 TCP 会出现两次连结的过程，HTTP 协议本身不保存状态信息，一次请求一次响应。对于 TCP 而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用 GET 请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。
2. GET 请求能够被 cache，GET 请求能够被保存在浏览器的浏览历史里面（密码等重要数据 GET 提交，别人查看历史记录，就可以直接看到这些私密数据）POST 不进行缓存。
3. GET 参数是带在 URL 后面，传统 IE 中 URL 的最大可用长度为 2048 字符，其他浏览器对 URL 长度限制实现上有所不同。POST 请求无长度限制（目前理论上是这样的）。
4. GET 提交的数据大小，不同浏览器的限制不同，一般在 2k-8K 之间，POST 提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。
5. 安全性、幂等性、可缓存性。

### HTTP2 和 HTTP1 有什么区别

-   相对于 HTTP1.0，HTTP1.1 的优化：

1. 缓存处理：多了 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存信息（HTTTP1.0 If-Modified-Since,Expires）
2. 带宽优化及网络连接的使用
3. 错误通知的管理
4. Host 头处理

-   长连接： HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

-   相对于 HTTP1.1，HTTP2 的优化：

1. HTTP2 支持二进制传送（实现方便且健壮），HTTP1.x 是字符串传送
2. HTTP2 支持多路复用
3. HTTP2 采用 HPACK 压缩算法压缩头部，减小了传输的体积
4. HTTP2 支持服务端推送

### HTTP 状态码

| code                     | status                                                     | intro                           |
| ------------------------ | ---------------------------------------------------------- | ------------------------------- |
| 信息响应 (100–199)       |
| 100                      | 接受，继续请求                                             | Continue                        |
| 成功响应 (200–299)       |
| 200                      | 成功，并返回数据                                           | OK                              |
| 201                      | 已创建                                                     | Created                         |
| 202                      | 已接受                                                     | Accepted                        |
| 203                      | 成功，但未授权                                             | Non-Authoritative Information   |
| 204                      | 成功，无内容                                               | No Content                      |
| 205                      | 成功，重置内容                                             | Reset Content                   |
| 206                      | 成功，部分内容                                             | Partial Content                 |
| 重定向消息 (300–399)     |
| 300                      | 请求拥有不只一个响应                                       | Multiple Choice                 |
| 301                      | 永久移动，重定向                                           | Moved Permanently               |
| 302                      | 临时移动，可使用原有 URI                                   | Found                           |
| 303                      | 指示客户端通过一个 GET 请求在另一个 URI 中获取所请求的资源 | See Other                       |
| 304                      | 资源未修改，可使用协商缓存                                 | Not Modified                    |
| 客户端错误响应 (400–499) |
| 400                      | 客户端错误，如请求语法错误                                 | Bad Request                     |
| 401                      | 要求身份认证，客户端必须对自身进行身份验证                 | Unauthorized                    |
| 403                      | 拒绝请求，客户端没有访问内容的权限                         | Forbidden                       |
| 404                      | 资源不存在                                                 | Not Found                       |
| 405                      | 目标资源不支持该方法                                       | Method Not Allowed              |
| 408                      | 请求超时                                                   | Request Timeout                 |
| 409                      | 请求与服务器的当前状态冲突                                 | Conflict                        |
| 服务端错误响应 (500–599) |
| 500                      | 服务器错误                                                 | Internal Server Error           |
| 501                      | 服务器不支持请求方法                                       | Not Implemented                 |
| 502                      | 网关错误的响应                                             | Bad Gateway                     |
| 503                      | 服务不可用，服务器没有准备好处理请求                       | Service Temporarily Unavailable |
| 504                      | 网关响应超时                                               | Gateway Timeout                 |
| 505                      | 服务器不支持请求中使用的 HTTP 版本                         | HTTP Version Not Supported      |

## HTTP 缓存

### 1. 强缓存

对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（ `Expires` 、 `Cache-Control` ）。

1. `Expires` 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据；`Expires` 是 HTTP 1.0 的东西，现在浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。此外到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以 HTTP 1.1 的版本，使用 `Cache-Control` 替代。

2. `Cache-Control` 常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。

-   private: 客户端可以缓存，防止信息泄漏；
-   public: 客户端和代理服务器都可缓存；
-   max-age=xxx: 缓存的内容将在 xxx 秒后失效；
-   no-cache: 需要使用对比缓存来验证缓存数据；
-   no-store: 所有内容都不会缓存，强制缓存、对比缓存都不会触发；
-   must-revalidate: 告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。

3. Pragma，HTTP/1.0 中规定的通用首部；用来向后兼容只支持 HTTP/1.0 协议的缓存服务器，那时候 HTTP/1.1 协议中的 `Cache-Control` 还没有出来。 只有一个值“no-cache”，与 `Cache-Control: no-cache` 效果一致。

### 2. 协商缓存

浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端可以使用缓存数据。缓存标识在请求 header 和响应 header 间进行传递，一共分为两种。

-   1. `Last-Modified(response header) / If-Modified-Since(request header)`:http1.0;
-   2. `ETag(response header) / If-None-Match(request header)`:http1.1;

ETag 在服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识，生成规则由服务器决定。ETag 优先级高于 Last-Modified，这里优先级指服务端优先级，客户端两者并存的情况下，都会在 request header 中带上，但是 Nginx 会优先匹配 Etag。

### 3. 例外：Last-Modified 命中强缓存

出现这种情况，一般是 Nginx 配置有问题，可以通过增加`add_header Cache-Control no-cache;`来解决。

在我们的认知里，通常 `Last-Modified` 是和协商缓存相关，但一些情况下也会触发启发式(heuristic)缓存。

如果服务器总是提供强缓存所需字段（ `Expires` 、 `Cache-Control` ），浏览器可以通过判断是否使用本地缓存文件，来实现更好的加载性能。但由于服务器不是总返回强缓存的 response 字段，此时浏览器会根据其他的 response header 字段来计算 `Cache-Control` 的 `max-age` 值（通常是 `Last-Modified` 字段）。HTTP/1.1 规范没有给出特定的实现算法，使得不同浏览器内核的浏览器对此表现不尽相同。

通常推荐的计算方法是 过期时间 < 时间间隔 \_ 系数。时间间隔指的是 response 的返回时间与最后更新时间的间隔，而这个系数的典型值是 10%，计算公式为：`max-age = ( date - last-modified ) * 0.1`，绝大多数的客户端，包括浏览器和各类 app 都是采用的这一推荐算法。

### HTTP 缓存别再乱用了！推荐一个缓存设置的最佳姿势！

0. 资源的缓存通常是有多级的，一些缓存专门用于单个用户，一些缓存专用于多个用户。有些是由服务器控制的，有些是由用户控制的，有些则由中介层控制。缓存的种类：

    - 浏览器缓存：一般并专用于单个用户，在浏览器客户端中实现。它们通过避免多次获取相同的响应来提高性能。
    - 本地代理：可能是用户自己安装的，也可能是由某个中介层管理的：比如公司的网络层或者网络提供商。本地代理通常会为多个用户缓存单个响应，这就构成了一种“公共”缓存。
    - 源服务器缓存/CDN。由服务器控制，源服务器缓存的目标是通过为多个用户缓存相同的响应来减少源服务器的负载。CDN 的目标是相似的，但它分布在全球各个地区，然后通过分配给最近的一组用户来达到减少延迟的目的。

1. 为了防止中介缓存，建议设置：`Cache-Control: private`;

-   禁用 Public Cache，减少了攻击者跨界访问到公共内存的可能性。

2. 建议设置适当的二级缓存 key：如果我们请求的响应是跟请求的 Cookie 相关的，建议设置：`Vary: Cookie;`

-   默认情况下，我们浏览器的缓存使用 URL 和 请求方法来做缓存 key 的。这意味着，如果一个网站需要登录，不同用户的请求由于它们的请求 URL 和方法相同，数据会被缓存到一块内存里。这显然是有点问题，我们可以通过设置 `Vary: Cookie` 来避免这个问题。当用户身份信息发生变化的时候，缓存的内存也会发生变化。

### 200 状态码和 304 状态码何时出现

1. 在没有设置 `Cache-Control` 的情况下，设置 `Last-Modified` 和 `ETag` 缓存，会出现 `200（from cache）`和 304 交替出现的情况。

2. 设置 `Cache-Control` 的情况下，过期刷新会出现 304(如果有更新内容，则是 200)，之后再过期之前刷新都是 `200（from cache）`。如果要确保要向服务端确认，可以将 `Cache-Control` 的 `max-age` 设置为 0。

## HTTP 版本对比

简单对比：

1. http1.0：最基础的 http 协议，支持基本的 get、post 方法
2. http1.1：目前广泛应用，增加缓存策略 `cache-control|E-tag` 等；支持长连接 `Connection:keep-alive`，一次 TCP 连接可以多次请求；支持断点续传，状态码 206；支持新的方法 put、delete 等，可用于 restful api；
3. http2.0：可压缩 header，减小体积；多路复用，一次 tcp 连接中可以多个 http 并行请求；支持服务端推送；

## websocket 和 http 的区别

0. 浏览器有原生 api
1. websocket 协议名是：ws 或者 wss，可双端发起请求、接收信息，先通过 http 协议建立连接，然后升级到 websocket 协议，`status code = 101`；
2. websocket 没有跨域限制；
3. 通过 send 和 onmessage 通讯，http 通过 request 和 response 通信；

-   http 长轮询：用来模拟服务端推送的。客户端发起请求，服务端阻塞等待，不会立即返回响应而是等到有数据之后才返回响应，而客户端收到响应后，又会立即再发送一个请求到服务端。如此往复。长轮询需要处理 timeout 机制，即 timeout 之后重新发起请求。

## 中间人攻击

1. https 加密过程，[加密过程](../assets/../../assets/zjrgj.png)
2. 中间人攻击，[原理](../assets/../../assets/zjr.png)
