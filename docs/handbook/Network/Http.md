---
title: Http协议
author: EricYangXD
date: "2022-01-04"
---

## http

### Methods

| 方法 Method | 幂等 Idempotent | 安全 Safe | 可缓存 Cacheable                                           |
| ----------- | --------------- | --------- | ---------------------------------------------------------- |
| HEAD        | Y               | Y         | Y                                                          |
| OPTIONS     | Y               | Y         | N                                                          |
| GET         | Y               | Y         | Y                                                          |
| PUT         | Y               | N         | N                                                          |
| DELETE      | Y               | N         | N                                                          |
| TRACE       | Y               | Y         | N                                                          |
| POST        | N               | N         | Only if freshness information is included 包含新鲜度信息时 |
| PATCH       | N               | N         | N                                                          |
| CONNECT     | N               | N         | N                                                          |

### 幂等

-   Q: 什么是幂等性?
-   A: 简单来说就是一个操作无论执行多少次，都会得到相同的结果，即 f(x)=f(f(x)).

### PATCH 和 PUT 方法的区别

1. PATCH 方法是新引入的，是对 PUT 方法的补充，用来对已知资源进行局部更新;
2. PATCH 请求中的实体是一组将要应用到实体的更改，而不是像 PUT 请求那样是要替换旧资源的实体;
3. PATCH 只传要更新的字段到指定资源去，表示该请求是一个局部更新，后端仅更新接收到的字段;
4. PUT 虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象;
5. PUT 是幂等的，而 PATCH 不一定是幂等的;
6. PUT 更新整个资源，即整个集合，所以 PUT 是幂等的;
7. PATCH 请求中的实体保存的是修改资源的指令，该指令指导服务器来对资源做出修改，所以不是幂等的，也就是，通过使用 PATCH，新资源可能被创造，或者现有资源被修改。
8. POST 方法一定不是幂等的；多次执行同样的操作，每一次都会创建一个相同的新资源。

### 杂记

1. 使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript 来读取这段 Cookie。
2. HTTP 本质是无状态的，使用 Cookies 可以创建有状态的会话。
3. 实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器、操作系统对它的限制。同理，POST 是没有大小限制的，HTTP 协议规范也没有进行大小限制。
4. 还会包括「代理」的因素在里面，可能 url 太长还没到服务，就已经被代理拒绝掉了。
5. 一般浏览器对 URL 长度的最大限制从 2083 个字符（IE)到 19 万个字符（Opera)不等，Chrome-8182 个字符，Apache (Server)-8192 个字符，Firefox-65536 个字符，等等。
6. 一般，URL 如果包含汉字，会进行转换 encodeURIComponent，如果浏览器的编码为 UTF8 的话，一个汉字最终编码后的字符长度为 9 个字符。因此如果使用的 GET 方法，最大长度等于 URL 最大长度减去实际路径中的字符数。

### GET VS POST：

1. 多数浏览器对于 POST 采用两阶段发送数据的，先发送请求头，再发送请求体，即使参数再少再短，也会被分成两个步骤来发送（相对于 GET），也就是第一步发送 header 数据，第二步再发送 body 部分。HTTP 是应用层的协议，而在传输层有些情况 TCP 会出现两次连结的过程，HTTP 协议本身不保存状态信息，一次请求一次响应。对于 TCP 而言，通信次数越多反而靠性越低，能在一次连结中传输完需要的消息是最可靠的，尽量使用 GET 请求来减少网络耗时。如果通信时间增加，这段时间客户端与服务器端一直保持连接状态，在服务器侧负载可能会增加，可靠性会下降。
2. GET 请求能够被 cache，GET 请求能够被保存在浏览器的浏览历史里面（密码等重要数据 GET 提交，别人查看历史记录，就可以直接看到这些私密数据）POST 不进行缓存。
3. GET 参数是带在 URL 后面，传统 IE 中 URL 的最大可用长度为 2048 字符，其他浏览器对 URL 长度限制实现上有所不同。POST 请求无长度限制（目前理论上是这样的）。
4. GET 提交的数据大小，不同浏览器的限制不同，一般在 2k-8K 之间，POST 提交数据比较大，大小靠服务器的设定值限制，而且某些数据只能用 POST 方法「携带」，比如 file。
5. 安全性、幂等性、可缓存性。

### HTTP2 和 HTTP1 有什么区别

-   相对于 HTTP1.0，HTTP1.1 的优化：

1. 缓存处理：多了 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等缓存信息（HTTTP1.0 If-Modified-Since,Expires）
2. 带宽优化及网络连接的使用
3. 错误通知的管理
4. Host 头处理

-   长连接： HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

-   相对于 HTTP1.1，HTTP2 的优化：

1. HTTP2 支持二进制传送（实现方便且健壮），HTTP1.x 是字符串传送
2. HTTP2 支持多路复用
3. HTTP2 采用 HPACK 压缩算法压缩头部，减小了传输的体积
4. HTTP2 支持服务端推送

### HTTP 状态码

| code | status                          |
| ---- | ------------------------------- |
| 1xx  | 接受，继续处理                  |
| 200  | 成功，并返回数据                |
| 201  | 已创建                          |
| 202  | 已接受                          |
| 203  | 成为，但未授权                  |
| 204  | 成功，无内容                    |
| 205  | 成功，重置内容                  |
| 206  | 成功，部分内容                  |
| 301  | 永久移动，重定向                |
| 302  | 临时移动，可使用原有 URI        |
| 304  | 资源未修改，可使用缓存          |
| 305  | 需代理访问                      |
| 400  | 请求语法错误                    |
| 401  | 要求身份认证                    |
| 403  | 拒绝请求                        |
| 404  | 资源不存在                      |
| 500  | 服务器错误                      |
| 502  | Bad Gateway                     |
| 503  | Service Temporarily Unavailable |

## HTTP 缓存

### 1. 强缓存

对于强制缓存来说，响应 header 中会有两个字段来标明失效规则（ Expires 、 Cache-Control ）。

1. Expires 的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据；Expires 是 HTTP 1.0 的东西，现在浏览器均默认使用 HTTP 1.1，所以它的作用基本忽略。此外到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。所以 HTTP 1.1 的版本，使用 Cache-Control 替代。

2. Cache-Control 常见的取值有 private、public、no-cache、max-age，no-store，默认为 private。

-   private: 客户端可以缓存，防止信息泄漏；
-   public: 客户端和代理服务器都可缓存；
-   max-age=xxx: 缓存的内容将在 xxx 秒后失效；
-   no-cache: 需要使用对比缓存来验证缓存数据；
-   no-store: 所有内容都不会缓存，强制缓存、对比缓存都不会触发；

3. Pragma，HTTP/1.0 中规定的通用首部；用来向后兼容只支持 HTTP/1.0 协议的缓存服务器，那时候 HTTP/1.1 协议中的 Cache-Control 还没有出来。 只有一个值“no-cache”，与 Cache-Control: no-cache 效果一致。

### 2. 协商缓存

浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端。再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回 304 状态码，通知客户端可以使用缓存数据。缓存标识在请求 header 和响应 header 间进行传递，一共分为两种。

-   1. Last-Modified(response header) / If-Modified-Since(request header)；
-   2. ETag(response header) / If-None-Match(request header);

ETag 在服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识，生成规则由服务器决定。其优先级高于 Last-Modified，这里优先级指服务端优先级，客户端两者并存的情况下，都会在 request header 中带上，但是 nginx 会优先匹配 Etag。

### 3. 例外：Last-Modified 命中强缓存

出现这种情况，一般是 Nginx 配置有问题，可以通过增加`add_header Cache-Control no-cache;`来解决。

在我们的认知里，通常 Last-Modified 是和协商缓存相关，但一些情况下也会触发启发式(heuristic)缓存。

如果服务器总是提供强缓存所需字段（ Expires 、 Cache-Control ），浏览器可以通过判断是否使用本地缓存文件，来实现更好的加载性能。但由于服务器不是总返回强缓存的 response 字段，此时浏览器会根据其他的 response header 字段来计算 Cache-Control 的 max-age 值（通常是 Last-Modified 字段）。HTTP/1.1 规范没有给出特定的实现算法，使得不同浏览器内核的浏览器对此表现不尽相同。

通常推荐的计算方法是 过期时间 < 时间间隔 \_ 系数。时间间隔指的是 response 的返回时间与最后更新时间的间隔，而这个系数的典型值是 10%，计算公式为：`max-age = ( date - last-modified ) * 0.1`，绝大多数的客户端，包括浏览器和各类 app 都是采用的这一推荐算法。

### HTTP 缓存别再乱用了！推荐一个缓存设置的最佳姿势！

1. 为了防止中介缓存，建议设置：Cache-Control: private;

禁用 Public Cache，减少了攻击者跨界访问到公共内存的可能性。

2. 建议设置适当的二级缓存 key：如果我们请求的响应是跟请求的 Cookie 相关的，建议设置：Vary: Cookie;

默认情况下，我们浏览器的缓存使用 URL 和 请求方法来做缓存 key 的。这意味着，如果一个网站需要登录，不同用户的请求由于它们的请求 URL 和方法相同，数据会被缓存到一块内存里。这显然是有点问题，我们可以通过设置 Vary: Cookie 来避免这个问题。当用户身份信息发生变化的时候，缓存的内存也会发生变化。
