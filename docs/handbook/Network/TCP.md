---
title: TCP协议
author: EricYangXD
date: "2022-01-27"
---

## 拥塞控制

为了防止网络的拥塞现象，TCP 提出了一系列的拥塞控制机制。

TCP 的拥塞控制主要原理依赖于一个拥塞窗口(cwnd)来控制，TCP 还有一个对端通告的接收窗口(rwnd)用于流量控制。窗口值的大小就代表能够发送出去的但还没有收到 ACK 的最大数据报文段，显然窗口越大那么数据发送的速度也就越快，但是也有越可能使得网络出现拥塞，如果窗口值为 1，那么就简化为一个停等协议，每发送一个数据，都要等到对方的确认才能发送第二个数据包，显然数据传输效率低下。TCP 的拥塞控制算法就是要在这两者之间权衡，选取最好的 cwnd 值，从而使得网络吞吐量最大化且不产生拥塞。

由于需要考虑拥塞控制和流量控制两个方面的内容，因此 TCP 的真正的发送窗口=min(rwnd, cwnd)。但是 rwnd 是由对端确定的，网络环境对其没有影响，所以在考虑拥塞的时候我们一般不考虑 rwnd 的值，我们暂时只讨论如何确定 cwnd 值的大小。

### 慢启动(Slow Start)

最初的 TCP 在连接建立成功后会向网络中发送大量的数据包，这样很容易导致网络中路由器缓存空间耗尽，从而发生拥塞。

因此新建立的连接不能够一开始就大量发送数据包，而只能根据网络情况逐步增加每次发送的数据量，以避免上述现象的发生。

具体来说，当新建连接时，cwnd 初始化为 1 个最大报文段(MSS)大小，发送端开始按照拥塞窗口大小发送数据，每当有一个报文段被确认，cwnd 就增加 1 个 MSS 大小。这样 cwnd 的值就随着网络往返时间(Round Trip Time,RTT)呈指数级增长，事实上，慢启动的速度一点也不慢，只是它的起点比较低一点而已。

### 拥塞避免(Congestion Avoidance)

从慢启动可以看到，cwnd 可以很快的增长上来，从而最大程度利用网络带宽资源，但是 cwnd 不能一直这样无限增长下去，一定需要某个限制。

TCP 使用了一个叫慢启动门限(ssthresh)的变量，当 cwnd 超过该值后，慢启动过程结束，进入拥塞避免阶段。

对于大多数 TCP 实现来说，ssthresh 的值是 65536(同样以字节计算)。拥塞避免的主要思想是加法增大，也就是 cwnd 的值不再指数级往上升，开始加法增加。此时当窗口中所有的报文段都被确认时，cwnd 的大小加 1，cwnd 的值就随着 RTT 开始线性增加，这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。

TCP 是如何确定网络进入了拥塞状态的--TCP 认为网络拥塞的主要依据是它重传了一个报文段。发生重传时：

1. 把 ssthresh 降低为 cwnd 值的一半
2. 把 cwnd 重新设置为 1
3. 重新进入慢启动过程。

从整体上来讲，TCP 拥塞控制窗口变化的原则是 AIMD 原则，即加法增大、乘法减小。可以看出 TCP 的该原则可以较好地保证流之间的公平性，因为一旦出现丢包，那么立即减半退避，可以给其他新建的流留有足够的空间，从而保证整个的公平性。

### 快速重传(Fast Retransmit)

收到 3 个相同的 ACK 也会进行重传。TCP 在收到乱序到达包时就会立即发送 ACK，TCP 利用 3 个相同的 ACK 来判定数据包的丢失，此时进行快速重传，快速重传做的事情有：

1. 把 ssthresh 设置为 cwnd 的一半
2. 把 cwnd 再设置为 ssthresh 的值(具体实现有些为 ssthresh+3)
3. 重新进入拥塞避免阶段。

### 快速恢复(Fast Recovery)

“快速恢复”算法是在上述的“快速重传”算法后添加的，当收到 3 个重复 ACK 时，TCP 最后进入的不是拥塞避免阶段，而是快速恢复阶段。快速重传和快速恢复算法一般同时使用。

快速恢复的思想是“数据包守恒”原则，即同一个时刻在网络中的数据包数量是恒定的，只有当“老”数据包离开了网络后，才能向网络中发送一个“新”的数据包，如果发送方收到一个重复的 ACK，那么根据 TCP 的 ACK 机制就表明有一个数据包离开了网络，于是 cwnd 加 1。如果能够严格按照该原则那么网络中很少会发生拥塞，事实上拥塞控制的目的也就在修正违反该原则的地方。

主要步骤是：

1. 当收到 3 个重复 ACK 时，把 ssthresh 设置为 cwnd 的一半，把 cwnd 设置为 ssthresh 的值加 3，然后重传丢失的报文段，加 3 的原因是因为收到 3 个重复的 ACK，表明有 3 个“老”的数据包离开了网络。
2. 再收到重复的 ACK 时，拥塞窗口增加 1。
3. 当收到新的数据包的 ACK 时，把 cwnd 设置为第一步中的 ssthresh 的值。原因是因为该 ACK 确认了新的数据，说明从重复 ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态。

### 快速恢复算法改进版

可以看出 Reno 的快速重传算法是针对一个包的重传情况的，然而在实际中，一个重传超时可能导致许多的数据包的重传，因此当多个数据包从一个数据窗口中丢失时并且触发快速重传和快速恢复算法时，问题就产生了。

因此 NewReno 出现了，它在 Reno 快速恢复的基础上稍加了修改，可以恢复一个窗口内多个包丢失的情况。具体来讲就是：Reno 在收到一个新的数据的 ACK 时就退出了快速恢复状态了，而 NewReno 需要收到该窗口内所有数据包的确认后才会退出快速恢复状态，从而进一步提高吞吐量。

### 选择性应答(Selective Acknowledgement, SACK)

SACK 就是改变 TCP 的确认机制，最初的 TCP 只确认当前已连续收到的数据，SACK 则把乱序等信息会全部告诉对方，从而减少数据发送方重传的盲目性。

比如说序号 1，2，3，5，7 的数据收到了，那么普通的 ACK 只会确认序列号 4，而 SACK 会把当前的 5，7 已经收到的信息在 SACK 选项里面告知对端，从而提高性能，当使用 SACK 的时候，NewReno 算法可以不使用，因为 SACK 本身携带的信息就可以使得发送方有足够的信息来知道需要重传哪些包，而不需要重传哪些包。
