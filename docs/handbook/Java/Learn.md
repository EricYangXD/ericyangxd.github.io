---
title: Learn Java
author: EricYangXD
date: "2022-09-30"
meta:
  - name: keywords
    content: JAVA
---

## Learn Java - Basic

### 基础语法

1. 定义变量要先声明类型
2. 数组的声明和定义：`int[] arr={1,2,3,5}`或`String[] str=new String[5]`
3. this
4. == : 基本类型比较的是具体数据值，引用类型比较的是引用地址值
   - 字符串拼接时，如果没有变量参与，都是字符串直接相加，编译之后就是拼接之后的结果，会复用串池中的字符串。（可以用==比较）
   - 如果有变量参与，每一行拼接的代码，都会在内存中创建新的字符串，浪费内存。（不可以用==比较）
5. JavaBean: 类名需要见名知意；成员变量使用 private 修饰；提供至少两个构造方法：无参和全参；成员方法：提供每个成员变量对应的 getter/setter 函数，如果还有其他行为也要写上。
6. 整数有四种类型：byte:1 字节，byte:2 字节，int:4 字节（默认），long:8 字节
7. 浮点数 2 种：float:4 字节，double:8 字节（默认）
8. 字符：char:2 字节（单引号&一个字符）
9. 布尔：boolean：1 字节

### String/StringBuilder/StringJoiner

1. String：最常用 `String s="string"`直接赋值，放在 StringTable 里（可能会复用，节约内存），通过 new 的形式创建的放在堆内存中不可复用，创建后不可修改，都是 String 类的实例对象，可以接受字符数组和字节数组创建字符串（要经过转换），有 equals、equalsIgnoreCase 等方法。
2. StringBuilder：可以看成是一个容器，创建之后里面的内容是可变的。作用是提高字符串的操作效率，有 append、reverse 等方法。
   - 默认创建一个长度为 16 的字节数组
   - 添加的内容长度小于 16，直接存
   - 添加的内容大于 16 则会扩容（原容量\*2+2）
   - 如果扩容之后还不够，以实际长度为准
3. StringJoiner：可以看成是一个容器，创建之后里面的内容是可变的。字符串拼接，可指定字符串拼接时的间隔符、起始符和结束符。

### HSDB 调试工具

1. 在 idea 的 terminal 输入：`jps`即可显示当前运行的类的 id
2. 在 idea 的 terminal 输入：`jhsdb hsdb`即可显示 HSDB 面板，然后点击 file，选择 attach，输入对应的 id 查看

### 继承

#### 子类到底能继承父类中的哪些内容？

| 内容     | 情况一            | 情况二                                         |
| -------- | ----------------- | ---------------------------------------------- |
| 构造方法 | 非私有 不能       | private 不能                                   |
| 成员变量 | 非私有 能         | private 能（但是要通过 getter、setter 来调用） |
| 成员方法 | 在虚方法表中的 能 | 其他的 不能                                    |

#### 代码块

1. 有`{}`局部代码块，已淘汰
2. 构造代码块：
   1. 写在成员位置的代码块
   2. 作用：可以把多个构造方法中重复的代码抽取出来
   3. 执行时机：在创建本类对象的时候会先执行构造代码块再执行构造方法
3. 构造代码块的形式不够灵活，可以用如下方式替代：
   1. 通过 this 调用其他构造方法
   2. 提取公共代码当做一个函数，按需调用这个函数
4. 静态代码块`static {}`，随着类的加载而加载，且只执行一次，比如做一些初始化操作

#### 总结

1. 继承中成员方法的访问特点：
   - this 调用：就近原则
   - super 调用：直接找父类
2. 方法重写：子类中出现和父类中一模一样的方法声明，@Override
3. @Override 注解可以校验重写是否正确，可读性好
4. 方法重写的本质：覆盖虚方法表中的方法
5. 父类中的构造方法不会被子类继承，子类中所有的构造方法默认先访问父类中的无参构造函数，再执行自己。因为子类在初始化的时候可能会用到父类中的数据，如果父类没有初始化，那么子类将无法使用父类的数据。子类构造方法的第一行默认语句都是`super()`，不写也存在。若要调用父类的有参构造，那么必须手动 super 来调用。

### 访问权限

1. 权限修饰符：private (只能自己用）< 缺省/默认/空着不写 (只能在本包中用) < protected (外面包里的子类也可以用) < public （都可以用）
2. 只有被添加到虚方法表中的方法才能重写，建议重写的方法尽量和父类保持一致

### 多态

1. 加载字节码文件时，永远是先加载父类，再加载子类
2. 调用成员变量的特点：编译看左边，运行也看左边
3. 调用成员方法的特点：编译看左边，运行看右边。编译的时候会先检查左边的父类中有没有这个方法，如果没有就直接报错。
4. 多态的优势：
   1. 在多态形式下，右边对象可以实现解耦合，便于扩展和维护
   2. 定义方法的时候，使用父类型作为参数，可以接收所有子类对象，体现多态的扩展性与便利
5. 弊端：不能使用子类特有的功能，需要手动进行类型转换
6. 引用数据类型的类型转换有两种方式：自动类型转换（子到父），强制类型转换（父到子）
7. 强制类型转换可以转换成真正的子类类型，从而调用子类独有的功能，但是，转换类型与真实类型不一致时会报错！所以可以用 instanceof 关键字进行判断先。

### 包

1. 包就是文件夹，用来管理各种不同功能的 Java 类，方便后期代码维护。`package com.hema.domain;`
2. 命名规则：公司的域名反写+包的作用，需要全部小写字母，见名知意。
3. 使用其他类的规则：
   1. 使用同一个包中的类时，不需要导包
   2. 使用 java.lang 包中的类时，不需要导包
   3. 其他情况都需要导包，例`import com.hema.domain.Student;`，idea 会自动导入或者让你自己选择导入哪个，`alt + Enter`
   4. 如果同时使用两个包中的同名类，需要使用全类名，例`com.hema.domain.Student;`

### final

1. 修饰方法时，表明该方法是最终方法，不能被重写
2. 修饰类，表明该类是最终类，不能被继承
3. 修饰变量，叫做常量，只能被赋值一次，类似 const

### 抽象类抽象方法

关键字 abstract，例：`public abstract void add();`

1. 抽象方法：将共性的行为（方法）抽取到父类之后，由于每一个子类执行的内容是不一样的，所以在父类中不能确定具体的方法体。该方法就可以定义为抽象方法。
2. 抽象类：如果一个类中存在抽象方法，那么该类就必须声明为抽象类。
   1. 不能实例化，
   2. 抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类
   3. 可以有构造方法，作用是：当创建子类对象时，给属性进行赋值的。
   4. 抽象类的子类：
      1. 要么重写抽象类中的所有抽象方法
      2. 要么是抽象类
3. 抽象方法，可以强制子类按统一的格式书写方法名之类的。

### 接口

0. 接口 interface，侧重于对行为的抽象，不能实例化，通过 implements 实现一个或多个接口。例`public interface Swim{}`，可以定一些抽象方法。

接口中成员的特点：通过内存分析工具 jps 可以看出来。

1. 成员变量只能是常量，默认修饰符：`public static final`
2. 没有构造方法
3. 成员方法只能是抽象方法，默认修饰符：`public abstract`
4. JDK7 以前：接口中只能定义抽象方法
5. JDK8：可以定义有方法体的方法（默认、静态），用于**接口升级**时起兼容的作用
   1. `public default void show(){}`
   2. 默认方法不是抽象方法，不强制重写。若要重写，则重写时需去掉 default 关键字
   3. public 可以省略，default 不能省略
   4. 如果实现了多个接口，多个接口中存在相同名字的默认方法，子类就必须对该方法进行重写
6. JDK9：可以定义私有方法
   1. `private void show(){}`，普通私有方法对应默认
   2. `private static void show(){}`，静态私有方法对应静态
7. 接口和类之间的关系：
   1. 类和类之间：继承关系，只能单继承，不能多继承，但可以多层继承
   2. 类和接口之间：实现关系，可以单实现也可以多实现，还可以在继承一个类的同时实现多个接口，需要重写所有抽象方法
   3. 接口和接口之间：继承关系，可以单继承，也可以多继承，需要重写所有抽象方法
8. 当一个方法的参数是接口时，可以传递接口所有实现类的对象，这种方式称之为接口多态。
9. 适配器模式：定义一个抽象类 xxxAdapter（一般不需要实例化），对一个接口的所有抽象方法进行空实现，然后在我们要用到的地方继承这个类，重写用到的某个方法即可，不需要在业务代码中实现接口中的所有抽象方法。相当于在接口和实现类之间添加的一层中间件。这个中间抽象类还可以继承其他类，让实现类进行间接继承。
10. 如果一个接口里面没有抽象方法，则表示当前的接口是个标记型接口。

### 内部类

1. 类的五大成员：属性、方法、构造函数、代码块、内部类。
2. 内部类：在一个类的里面，再定义一个类。
3. 内部类表示的事物是外部类的一部分，单独出现没有任何意义
4. 内部类的访问特点：
   1. 内部类可以直接访问外部类的成员，包括私有
   2. 外部类要访问内部类的成员，必须创建对象
5. 4 种：
   1. 成员内部类:可以被 private、默认、protected、public、static 等；JDK16 之前不能定义静态变量，16 开始才可以。
   2. 静态内部类:只能访问外部类中的静态变量和静态方法，如果想访问非静态的，需创建外部类的实例对象再调用。
   3. 局部内部类:定义在方法里面，类似方法里面的局部变量。外界无法直接使用，需要在方法内部创建对象并使用。该类可以直接访问外部类的成员和方法内的局部变量。
   4. 匿名内部类:隐藏了名字的内部类。可以写在成员位置或者局部位置。格式：`new 类名/接口名(){ 重写方法 }`。整体就是一个类的子类对象或者接口的实现类对象。
6. 获取成员内部类对象的两种方式：

   1. 外部类编写方法，对外提供内部类对象
   2. 直接创建：`Outer.Inner oi = new Outer().new Inner();`

7. 外部类成员变量和内部类成员变量重名时，在内部类通过这种形式访问外部变量：`Outer.this.xxx`
8. `javap xxx.class`：反编译 class 文件，Java 自带功能。
9. 匿名内部类使用场景：
   1. 当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只要使用一次，就可以用匿名内部类简化代码。

## 常用 Api

### Math

1. abs
2. round
3. ceil：向数轴右侧取整
4. floor：向数轴左侧取整
5. sqrt：开方
6. cbrt：开立方
7. max/min
8. absExact：防止溢出

### System

1. exit
2. currentTimeMillis
3. arraycopy(source,start,target,start,length)

### Runtime

1. Runtime.getRuntime()
2. Runtime.getRuntime().exit()
3. Runtime.getRuntime().totalMemory()

### Object

最高父类

1. toString()
2. equals()
3. clone()
4. Objects：工具类
   1. equals：先做非空判断再调用第一个入参的 equals 方法比较
   2. isNull
   3. nonNull

### BigInteger & BigDecimal

#### BigInteger

1. 对象一旦创建，内部记录的值就不能再变。
2. new BigInteger("13412")：常用，字符串中必须是整数
3. BigInteger.valueOf(1232L)：常用，参考 6，有优化。
4. new BigInteger("13453",2 进制)
5. new BigInteger(int num, Random rnd):获取指定范围的随机大整数 2^num
6. 对-16~16 的数字做了优化，多次创建都是同一个对象。
7. BigInteger 方法：

   1. add, subtract, multiply, divide, divideAndRemainder, equals, pow, max, min, intValue, doubleValue

8. 存储上限：

   1. 数组中最多能存储的元素个数：21 亿多
   2. 数组中每一位能表示的数字：42 亿多
   3. BigInteger 能表示的最大数字为：42 亿的 21 亿次方

9. 存储形式：先转换成二进制补码，一位符号位，其余 bit 按 32 位一组，存到数组中。

#### BigDecimal

小数计算结果精确

1. BigDecimal.valueOf(number/string)：常用
2. new BigDecimal(string)：常用
3. 对 0~10 之间的整数，会返回已经创建好的对象，不会重新 new
