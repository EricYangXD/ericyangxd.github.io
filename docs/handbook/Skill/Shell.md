---
title: Learn Shell
author: EricYangXD
date: "2022-08-05"
meta:
  - name: keywords
    content: shell
---

## 学习 Shell 脚本

### 基础概念

0. 如果提示符的最后一个字符是“#”, 而不是“$”, 那么这个终端会话就有超级用户权限。 这意味着，我们要么是以 root 用户的身份登录，要么是我们选择的终端仿真器提供超级用户（管理员）权限。

1. Shell 脚本的解释过程就是从文件读入字符流，然后进行处理，最后将结果传送至某个文件，所以交互式 Shell 命令与 Shell 脚本在本质上并没有区别，只是 Shell 命令的输入是标准输入，输出是标准输出。

2. Shell 脚本的注释以#符号开始，一直到行末结束，例如可以在 Shell 命令行中输入以#开头的命令，则该命令将会被作为注释而忽略处理。
3. Sha-Bang 是 Shell 脚本开头字符#!连在一起的读音，当 Shell 文件被 Linux 系统读取时，内核会通过#!表示的值（0x23, 0x21）识别出随后的解释器路径并调用，最后再将整个脚本内容传递给解释器。由于 Shell 当中#字符同时表示注释，因此 Shell 解释脚本文件时会自动忽略该行。

### 执行方式

Shell 脚本的执行主要存在如下 5 种方式：

1. 将**拥有执行权限**的脚本作为命令调用，例如：`./hello.sh`；
2. 显式使用 Shell 程序，将脚本文件作为参数来执行，例如：`sh hello.sh`；
3. 将脚本文件重定向至 Shell 程序的标准输入，例如：`sh < hello.sh`；
4. 通过**管道符**将脚本内容输出至 Shell 程序的标准输入，例如：`cat hello.sh | sh`；
5. 使用 source 命令执行，例如：`source hello.sh`；

### 字符串与引号

Shell 解释器采用了字符流过滤器模型，简而言之，就是一条命令将结果送到标准输出，这个标准输出被连接到下一条命令的标准输入，每条命令的输出结果都是自己处理之后的字符流，接受的输入都是需要进行处理的字符流，所以字符串是 Shell 当中非常重要的组成部分。

Shell 当中存在'、"、`三种引号类型，其具体使用区别分别如下所示：

1. 单引号`'`当中的字符串 Shell 不会进行处理，仅在需要保持字符串原样不变的时候使用；
2. 双引号`"`当中的字符串 Shell 会进行处理，如果其中包含有可以求值的部分（变量、表达式、命令），则会被 Shell 替换为相应的求值结果；
3. 反引号\`用于引用一条 Linux 命令，其作用是将该命令的执行结果输出，效果类似于`$()`；

### 特殊字符

1. `*`和`?`都是通配符，前者匹配任意个字符，后者仅匹配一个字符；
2. `:`表示空命令，其返回值恒为 0，循环语句当中，可以与 true 命令等价；
3. `;`是分行符，标识一行命令结束，可以通过它将多条命令编写在一行；
4. `$`可以用于获取变量或者表达式的值，结合大括号`${}`使用，可以在变量出现在字符串当中时，不与字符串内容相混淆；结合小括号`$()`可以取一个命令的值作为字符串内容，其效果与反引号\`相同；通过双小括号`$(())`可以取得一个数学表达式的计算结果，例如在使用`*`运算符计算一个乘积；
5. `.`句点符号，等效于 source 命令，可用于在 Shell 进程上调用脚本；
6. `\`反斜线表示转义符，是一种引用单个字符的方法，也可以用于 Shell 命令的换行；
7. 空格作为参数命令的做分隔符，例如：`touch a b`会创建 a 和 b 两个文件，而`touch c\ d`则只会创建一个名为'c d'文件；

### 内/外部命令

1. 外部命令：Shell 的绝大多数命令如同/bin/ls 一样，是一个独立的外部可执行程序。当外部命令被调用时，本质就是调用了另外一个程序，首先 Shell 会创建子进程，然后在子进程当中运行该程序；
2. 内部命令：内建在 Shell 程序当中，由 Shell 软件内部进行实现的命令，例如：cd、source、export、time 等，它们都运行在 Shell 进程当中。
3. 注意：如果希望脚本能够改变当前 Shell 自身的一些属性，则必须在 Shell 进程内执行调用。例如修改/etc/profile、~/.profile、~/.bashrc 环境变量之后，必须使用 source 命令执行它们，以使其生效。

### 重定向

1. Shell 的设计哲学是字符流 + 过滤器，即将一个程序的输出，作为另一个程序的输入，这样就能将各种用途简单的小工具组合起来，完成一些看起来不可思议的功能。

2. 默认情况下，Linux 当中的每一个进程都拥有 3 个特殊的文件描述指针：

- 标准输入 stdin：Standard Input，文件描述指针为 0；
- 标准输出 stdout：Standard Output，文件描述指针为 1；
- 标准错误输出 stderr：Standard Eror，文件描述指针为 2；

3. IO 重定向就是捕捉命令、程序、脚本甚至代码块的输出，然后将其作为输入传递给另外的文件、命令、程序、脚本。

#### 输出重定向

输出重定向符号`>`和`>>`，可以将标准输出重定向至一个文件当中，如果该文件不存在则创建文件。其中，前者`>`会覆盖原文件内容，后者`>>`则会在原文件尾部追加新的内容。

#### 输入重定向

输出重定向符号`<`和`<<`，用于将标准输入重定向至一个文件。如果`<`后跟着一个 Shell 脚本文件，则相当于将`.sh`脚本中的命令逐条输入至 Shell 程序当中执行。

`<<`可以用于 `Here Document`， 即将文本直接写在 Shell 脚本之中，并以添加终止符`EOF`（即 Linux 系统读取至文件结尾时所返回的信号值-1），该文本相当于一份独立的文件内容。

执行下面的脚本，会先打印两行 string，然后打印当前目录下的文件 list，然后生成一个 hello.js 文件并写入一行代码，然后执行这个 js 文件，打印出 string，最后列出当前目录下的文件 list 并删除 hello.js 文件。

```bash
echo Hello World
echo Second Hello World
ls -l

cat>hello.js<<EOF

console.log("Hi, this is js");

EOF

node hello.js

ls -l

rm hello.js
```

注意：Here Document 通常用于进行复杂的多行文本输入时，从而代替 echo 命令繁琐的硬编码操作。

### 管道

管道符`|`用于连接 Linux 命令，前一条命令的标准输出会成为下一条命令的标准输入。管道的最大特点在于是管道符`|`两边分别属于不同的进程。

例如：从 dmesg 输出的内核日志信息中，通过 grep 查找 USB 相关的内容。`$ dmesg | grep USB`

### 常量与变量

1. Shell 支持多种进制的整型常量，例如以`0`开头的八进制，以`0x`开头的十六进制。对于非八进制、十进制、十六进制的整数，可以表示为进制#数字格式，例如：三进制数`(120)₃`可以表示为`3#120`，转换为十进制值为 15。

2. Shell 中的变量在使用前不需要声明，赋值时可以直接使用变量名，且赋值的等号=两边不能有空格。变量定义之后，引用变量时一定需要使用`$`/`${}`符号。

3. Shell 变量没有类型，例如 annum=2020，既可以作为十进制整数 2020 直接参与算术运算，也可以作为字符串来进行处理。

- 使用 let 计算一个算术表达式并且赋值给变量：`let "annum+=1"`
- 将字符串变量中的 202 替换成为 203：`b=${annum/202/203}; echo b; # 2031`

4. Shell 变量有作用域，默认为对整个 Shell 文件有效的全局变量。局部变量则需要使用 local 关键字进行声明，其只在声明所在的块或者函数当中可见。

```bash
#!/bin/bash
# test.sh
test() {
    variable1=GLOBAL
    local variable2=LOCAL
    echo "函数内部，variable1=$variable1, variable2=$variable2" # 两个都能打印出来
}

test # 执行一下test函数

echo "函数外部，variable1=$variable1, variable2=$variable2" # 只能打印variable1
```

5. `?`问号也是一个变量，通过`$?`可以引用上一条命令的返回值，但是该值只能使用一次，使用完以后就会被目前命令的返回值所替换。

- false 命令返的回值恒为 1
- echo 命令的返回值为 0

### 环境变量

环境变量是可以改变 Shell 行为的变量，每个进程都拥有各自的环境变量，以用于保存进程相关的各种信息。环境变量的定义通常都是约定俗成的，例如：PATH 定义了 Shell 进程查找命令程序的路径。`echo $PATH`

Shell 当中的任何变量都可以通过 export 导出为环境变量，环境变量可以被子进程继承，因此也可以被视为父子进程信息传递的一种方式。

`$ export PATH="$PATH:/workspace"`可以给 PATH 后面添加`:/workspace`的环境变量。

### 位置参数

位置参数是指调用 Shell 脚本时，按照命令行位置进行引用的参数。脚本当中按照`$0`、`$1`、`$2`的顺序逐个进行引用，依此类推。其中`$0`就代表命令本身。

命令行参数相关的特殊变量还有`$#`、`$*`、`$@`，其使用方法如下所示：

- `$#`：代表命令行参数的个数；
- `$*`：代表全部命令行参数，全部参数作为一个字符串；
- `$@`：代表所有命令行参数，每个参数都是一个独立的字符串；

### 操作符

Shell 当中的每一条命令同时也是一个逻辑表达式，其返回值为 0 表示真，返回值为非 0 表示假，该值本质上就是当前命令所对应 main()函数的返回值，可以通过`$?`来进行获取。Shell 支持基本的数学运算符号以及各种逻辑操作符。

1. 数学运算符包括`+、-、*、/、%`以及幂运算`**`，Bash Shell 本身只支持整数运算，如果需要使用到浮点运算，则可以调用`bc`和`dc`等外部命令。
2. 逻辑操作符包括&&和||，分别代表逻辑与和逻辑或。对于逻辑与&&而言，如果左侧表达式为 false，则右侧表达式无需执行(实际也不会执行)即可确定整个表达式的结果为 false；

### 脚本返回值

通常情况下，Shell 脚本在最后都应该拥有一个返回值，如果未**显式的通过 exit 指定返回值**，则「默认使用脚本最后一条命令的返回值」；

### 函数

Shell 脚本当中的函数有 2 种定义方法，其中一种是通过 function 关键字进行定义：另外一种与 C 语言当中函数的定义方式相类似，这种方式可移植性更好，更加推荐使用：

```bash
# 1
function function_name(){
  # command
}

# 2
function_name(){
  # command
}
```

Shell 脚本当中的函数有 2 种定义方法，其中一种是通过 function 关键字进行定义：另外一种与 C 语言当中函数的定义方式相类似，这种方式可移植性更好，更加推荐使用：

### 条件测试

Shell 提供了一系列条件测试运算符，用于判断某种条件是否成立，条件测试运算符主要包含如下 3 种：

```bash
test expression
[ expresssion ]    # 条件和左右括号之间必须带有空格
[[ expression ]]   # 新版本 Bash Shell 提供
```

#### 文件测试

文件测试通常用于判断文件属性，常用的文件测试条件如下所示：

| 条件            | 含义                                     | 示例                                |
| --------------- | ---------------------------------------- | ----------------------------------- |
| -e 或-a         | 文件存在（-a 已弃用）                    | `[ -e ~/.bashrc ]`                  |
| -f              | 普通文件                                 | `[ -f ~/.profile ]`                 |
| -s              | 文件长度不为 0                           | `[ -s /etc/mtab ]`                  |
| -d              | 文件是目录                               | `[ -d /etc ]`                       |
| -b              | 文件是块设备文件                         | `[ -b /dev/sda ]`                   |
| -c              | 文件是字符设备                           | `[ -c /dev/ttyS0 ]`                 |
| -p              | 文件是管道                               | `[ -p /tmp/fifo ]`                  |
| -h/-L           | 文件是符号链接                           | `[ -L /etc/mtab ]`                  |
| -S              | 文件是 Socket                            | `[ -S /tmp/socket ]`                |
| -t              | 是否为关联到终端的文件描述符             | `[ -t /dev/stdout ]`                |
| -r              | 文件可读                                 | `[ -r ~/.bashrc ]`                  |
| -w              | 文件可写                                 | `[ -w ~/.profile ]`                 |
| -x              | 文件可执行                               | `[ -x /bin/ls ]`                    |
| -g              | 文件有 SGID 标识                         | `[ -g /bin/su ]`                    |
| -u              | 文件有 SUID 标识                         | `[ -u /usr/bin/sudo ]`              |
| -k              | 具有粘滞位                               | `[ -k /tmp ]`                       |
| -O              | 测试者是文件拥有者                       | `[ -O ~/.bashrc ]`                  |
| -G              | 文件的组 ID 与测试者相同                 | `[ -G ~/.profile ]`                 |
| -N              | 文件从最后一次查看到现在，是否有被修改过 | `[ -N ~/.profile ]`                 |
| file1 -nt file2 | 文件 file1 比文件 file2 更新             | `[ ~/.bashrc –nt ~/.profile ]`      |
| file1 -ot file2 | 文件 file1 比文件 file2 更旧             | `[ ~/.bashrc –ot ~/.profile ]`      |
| file1 -ef file2 | file1 和 file2 都是同一个文件的硬链接    | `[ /usr/bin/test -ef /usr/bin/\[ ]` |
| !               | 取反测试结果，如果没有条件则返回 true    | `[ ! -d ~/.profile ]`               |

#### 整数比较

| 条件 | 含义                         | 示例                |
| ---- | ---------------------------- | ------------------- |
| -eq  | 等于                         | `[ "$m" -eq "$n" ]` |
| -ne  | 不等于                       | `[ "$m" -ne "$n" ]` |
| -gt  | 大于                         | `[ "$m" -gt "$n" ]` |
| -ge  | 大于等于                     | `[ "$m" -ge "$n" ]` |
| -lt  | 小于                         | `[ "$m" -lt "$n" ]` |
| -le  | 小于等于                     | `[ "$m" -le "$n" ]` |
| <    | 小于，需要以(())方式测试     | `(( "$m" < "$n"))`  |
| <=   | 小于等于，需要以(())方式测试 | `(( "$m" <= "$n"))` |
| >    | 大于，需要以(())方式测试     | `(( "$m" > "$n"))`  |
| >=   | 大于等于，需要以(())方式测试 | `(( "$m" >= "$n"))` |

#### 字符串比较

| 条件  | 含义                                                      | 示例                     |
| ----- | --------------------------------------------------------- | ------------------------ |
| =或== | 相等，==在`[]`和`[[]]`里的行为可能会表现不同              | `[ "$str1" = "$str2" ]`  |
| !=    | 不相等                                                    | `[ "$str1" != "$str2" ]` |
| >     | 大于，按照 ASCII 顺序进行比较，在[]中使用时需要转义为`\>` | `[ "$str1" \> "$str2" ]` |
| <     | 小于，按照 ASCII 顺序进行比较，在[]中使用时需要转义为`\<` | `[ "$str1" \< "$str2" ]` |
| -z    | 长度为 0                                                  | `[ -z "$str" ]`          |
| -n    | 长度不为 0，在[]当中使用时，需要将字符串放入""里面        | `[ -n "$str" ]`          |

#### 混合比较

条件测试还支持在多个表达式之间进行逻辑运算，其中-a 表示与运算，-o 表示或运算。下面的示例用于测试命令行参数提供的整数是否介于 0 ~ 100 之间，若位于该区间范围输出 yes，不在则向控制台输出 no。

```bash
#!/bin/bash
# compare.sh
[ "$1" -ge 0 -a "$1" -le 100 ] && echo yes || echo no
[ "$1" -lt 0 -o "$1" -gt 100 ] && echo no || echo yes
```

### 条件判断

#### if then

根据 if 表达式的逻辑值，决定是否执行 then 里的内容。通常 if 会与条件测试表达式一同使用，但也可以结合其它命令或者函数。最后，if 需要通过 fi 结束条件流程。

```bash
if 条件
  then
    代码块
fi
```

如果 if 与 then 编写在相同的行，则需要额外再添加一个;分号：

```bash
if 条件; then
  代码块
fi
```

#### if then else

条件流程控制语句还可以拥有一个 else 分支，用于条件不成立的情况。

```bash
if 条件; then
    代码块 1
  else
    代码块 2
fi
```

#### if then elif else

如果存在多个并列并且互斥的条件，则可用采用 elif 来依次判断条件：

```bash
if 条件1; then
    # 代码块 1
  elif 条件2; then
    # 代码块 2
  # ... ...
  elif 条件n; then
    # 代码块 n
  else
    # 代码块 n+1
fi
```

### 循环结构

Bash Shell 支持 for、while、until 三种不同类型的循环，其循环体当中的内容必须包含在 do 和 done 语句之间。

#### for 循环

for 循环的列表是一个由空格分隔的字符串列表，支持通配符。如果缺省，则会自动使用当前的命令行参数列表`$@`。列表当中的通配符会被 Shell 展开。

```bash
# `[]`可以省
for 参数 in [列表]
  do
    命令
  done
```

Bash Shell 同时也通过双小括号`(( ))`支持 C 风格的 for 循环。

```bash
for ((表达式 1; 表达式 2; 表达式 3))
  do
    命令
  done
```

#### while 循环

while 循环根据测试条件，反复执行循环体直至条件为假，同样拥有 Shell 和 C 两种风格。

```bash
# Shell 风格 `[]`不能省
while [条件]
  do
    命令
  done

# C 风格
while ((表达式))
  do
    命令
  done
```

#### until 循环

until 循环与 while 类似，但是 util 循环是在条件为假时执行循环体，直至条件为真时才结束循环。

```bash
until [条件]
  do
    命令
  done

# 或者
until ((表达式))
  do
    命令
  done
```

### 跳出循环

Shell 循环结构当中，可以使用 break 或者 continue 跳出循环，它们都可以携带一个用于标识所要跳出循环层数的数值，该数值缺省情况下为 1，表示仅跳出当前所在循环。

#### break

Bash Shell 当中的 break 关键字用于中断整个循环，其具体用法如下：`break n`，n 表示跳出循环的层数，如果省略 n，则表示仅中断当前循环。break 关键字通常与 if 语句联用，即满足条件时中断循环。

#### continue

Bash Shell 当中的 continue 关键字用于跳出本次循环，其具体用法如下：`continue n`，其中，n 表示循环层数，缺省值为 1。即如果省略，则 continue 仅跳出其所在的循环语句，忽略本次循环当中剩余代码的执行，直接进入下一次循环。如果将 n 的值设置为 2，那么 continue 会对内外两层的循环语句都有效，不但会跳出内层循环，还会跳出外层循环。continue 通常与 if 配合使用，在满足条件时跳出本次循环。

#### 分支结构 case in esac

Shell 通过 case in esac 语句实现分支结构，该结构与 C 语言中的 switch case 语句非常类似。

每个条件行都使用)结尾，每个条件块都以;;结尾（），关键字 esac 用于终止整个分支结构。

```bash
case "$variable" in
  "$condition1")
    命令
  ;;
  "$condition2")
    命令
  ;;
esac
```

## 语法知识点

#### date

显示系统当前时间和日期。

#### cal

一个和 date 相关联的命令，cal，它默认显示当前月份的日历。

#### df

查看磁盘剩余空间的数量

#### free

显示空闲内存的数量

#### 结束终端会话

可以通过关闭终端仿真器窗口，或者是在 shell 提示符下输入 exit 命令来终止一个终端会话

#### pwd/cd/ls

- `pwd`:打印出当前工作目录名
- `cd`:更改目录
- `ls`:列出目录内容:
  - `-l`:结果以长模式输出
  - `-t`:按文件修改时间的先后来排序
  - `-r`:结果会以相反的顺序输出
  - `-a`:列出全部文件，包括以 `.` 字符开头的隐藏文件
  - `-d`:通常，如果指定了目录名，ls 命令会列出这个目录中的内容，而不是目录本身。 把这个选项与 -l 选项结合使用，可以看到所指定目录的详细信息，而不是目录中的内容。
  - `-F`:这个选项会在每个所列出的名字后面加上一个指示符。例如，如果名字是 目录名，则会加上一个'/'字符。
  - `-h`:当以长格式列出时，以人们可读的格式，而不是以字节数来显示文件的大小。
  - `-l`:以长格式显示结果。
  - `-S`:命令输出结果按照文件大小来排序。
- `ls path1 <path2 ...>`:列出对应路径下的所有文件
- 文件名和命令名是大小写敏感的
- Linux 没有“文件扩展名”的概念
- 虽然 Linux 支持长文件名，文件名可能包含空格，标点符号，但标点符号仅限 使用 “.”，“－”，下划线。最重要的是，不要在文件名中使用空格。如果你想表示词与 词间的空格，用下划线字符来代替。

#### `/`

绝对路径时是当前硬盘根目录

#### `~`

- `cd`/`cd ~`/`cd ~<username>`:进入你的 home 目录，即`/Users/<username>`目录下。
- `cd -`:更改工作目录到先前的工作目录。

#### 相对路径

符号 `.` 指的是工作目录，`..` 指的是工作目录的父目录。在几乎所有的情况下，你可以省略`./`。它是隐含的。总的来说，如果不指定一个文件的路径，那它被默认为在当前工作目录下。

#### file/less

- `file filename`:确定文件类型
- `less filename`:浏览文件内容

#### 操作文件和目录

1. `cp` — 复制文件和目录，`cp test1 test2`:把 test1 文件夹复制到 test2 下，test2 多出一个 test1 目录；`cp test1/* test2`:把 test1 下的内容复制到 test2 下，不包含 test1 这一目录。
   |选项|意义|
   |--|--|
   |`-a, --archive` | 复制文件和目录，以及它们的属性，包括拥有者和所有权。 通常情况下，文件拷贝具有执行拷贝操作的用户的默认属性。|
   |`-i, --interactive` | 在覆盖已存在文件之前，提示用户确认。如果这个选项不指定， cp 命令会默认覆盖文件。|
   |`-r, --recursive` | 递归地复制目录及目录中的内容。当复制目录时， 需要这个选项（或者 -a 选项）。|
   |`-u, --update` | 当把文件从一个目录复制到另一个目录时，仅复制 目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在文件的内容的文件。|
   |`-v, --verbose` | 显示翔实的命令操作信息|
2. `mv` — 移动/重命名文件和目录
   |选项 |意义|
   |--|--|
   |`-i --interactive`| 在覆盖一个已经存在的文件之前，提示用户确认信息。 如果不指定这个选项，mv 命令会默认覆盖文件内容。|
   |`-u --update`| 当把文件从一个目录移动另一个目录时，只是移动不存在的文件， 或者文件内容新于目标目录相对应文件的内容的文件。|
   |`-v --verbose` |当操作 mv 命令时，显示翔实的操作信息。|
3. `mkdir` — 创建目录，可同时创建一个或多个
4. `rm` — 删除文件和目录
   |选项|意义|
   |--|--|
   |`-i, --interactive`| 在删除已存在的文件前，提示用户确认信息。 如果不指定这个选项，rm 会默默地删除文件|
   |`-r, --recursive`| 递归地删除文件，这意味着，如果要删除一个目录，而此目录 又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。|
   |`-f, --force`| 忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。|
   |`-v, --verbose`| 在执行 rm 命令时，显示翔实的操作信息。|
5. `ln` — 创建硬链接和符号链接: `ln file link`:创建硬链接，`ln -s item link`:创建符号/软链接，”item” 可以是一个文件或是一个目录。

   - 一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联 与链接本身不在同一个磁盘分区上的文件。
   - 一个硬链接不能关联一个目录。
   - 一个硬链接和文件本身表面上看不出什么区别。它跟符号链接很不一样，当你列出一个包含硬链接的目录 内容时，你会看不到有什么特殊说明来表示这是一个链接。当一个硬链接被删除时，这个链接 被删除，但是文件本身的内容仍然存在（这是说，它所占的磁盘空间不会被释放）， 直到所有关联这个文件的链接都删除掉。
   - 创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个 特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面， 它们和 Windows 的快捷方式差不多
   - 一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。 例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而， 当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接 删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为 坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们 的存在。
   - 建立符号链接的目的是为了克服硬链接的两个缺点：硬链接不能跨越物理设备， 硬链接不能关联目录，只能是文件。符号链接是文件的特殊类型，它包含一个指向 目标文件或目录的文本指针。
   - 对于符号链接，有一点值得记住，执行的大多数文件操作是针对链接的对象，而不是链接本身。 而 rm 命令是个特例。当你删除链接的时候，删除链接本身，而不是链接的对象。

6. 通配符：类似正则
   |通配符|意义|
   |--|--|
   |`*`|匹配任意多个字符（包括零个或一个）|
   |`?`|匹配任意一个字符（不包括零个）|
   |`[characters]`|匹配任意一个属于字符集（characters）中的字符|
   |`[!characters]`|匹配任意一个不是字符集中的字符|
   |`[[:class:]]`|匹配任意一个属于指定字符类中的字符|
   |`mv file1 file2` |移动 file1 到 file2。如果 file2 存在，它的内容会被 file1 的内容覆盖。 如果 file2 不存在，则创建 file2。 这两种情况下，file1 都不再存在。|
   |`mv -i file1 file2` |除了如果 file2 存在的话，在 file2 被覆盖之前，用户会得到 提示信息外，这个和上面的选项一样。|
   |`mv file1 file2 dir1`| 移动 file1 和 file2 到目录 dir1 中。dir1 必须已经存在。|
   |`mv dir1 dir2` |如果目录 dir2 不存在，创建目录 dir2，并且移动目录 dir1 的内容到 目录 dir2 中，同时删除目录 dir1。如果目录 dir2 存在，移动目录 dir1（及它的内容）到目录 dir2。|
7. 最常用字符类
   |字符类 |意义|
   |--|--|
   |`[:alnum:]`| 匹配任意一个字母或数字|
   |`[:alpha:]` |匹配任意一个字母|
   |`[:digit:]` |匹配任意一个数字|
   |`[:lower:]` |匹配任意一个小写字母|
   |`[:upper:]` |匹配任意一个大写字母|
8. TIPS: 当你使用带有通配符的 rm 命令时（除了仔细检查输入的内容外）， 先用 ls 命令来测试通配符。这会让你看到将要被删除的文件是什么。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls。

#### 命令

1. type – 说明一个命令名是如何被解释的（这里的“解释”是一个计算机术语，例如，解释型语言）。是 shell 内部命令，它会显示命令的类型，给出一个特定的命令名（做为参数）。
2. which – 显示会执行哪个可执行程序（即这个可执行程序的位置）。which 命令只对可执行程序有效，不包括内建命令和命令别名。
3. man – 显示命令手册页
4. apropos – 显示一系列适合的命令
5. info – 显示命令 info
6. whatis – 显示一个命令的简洁描述
7. alias – 创建命令别名
8. 联合命令：`cd /usr; ls; cd -`，创建别名示例：`alias foo='cd /usr; ls; cd -'`(等号和命令之间不能有空格)
9. 删除别名，使用 unalias 命令，像这样：`unalias foo`

#### 重定向

1. cat － 连接文件，读取一个或多个文件，然后复制它们到标准输出。cat 经常被用来显示简短的文本文件。因为 cat 可以 接受不只一个文件作为参数，所以它也可以用来把文件连接在一起。例：`cat movie.mpeg.0* > movie.mpeg`，因为通配符总是以有序的方式展开，所以这些参数会以正确顺序安排。
2. sort － 排序文本行
3. uniq － 报道或省略重复行。使用 uniq 从 sort 命令的输出结果中，来删除任何重复行:`ls /bin /usr/bin | sort | uniq | less`。如果我们想看到 重复内容，让 uniq 命令带上`-d`选项:`ls /bin /usr/bin | sort | uniq -d | less`
4. grep － 打印匹配行。grep 是个很强大的程序，用来找到文件中的匹配文本。`grep pattern [file...]`，`-i`使得 grep 在执行搜索时忽略大小写（通常，搜索是大小写 敏感的），`-v`选项会告诉 grep 只打印不匹配的行。
5. wc － 打印文件中换行符个数（行数），字数，和字节数。wc（字数统计）命令是用来显示文件所包含的行数、字数和字节数。`-l`选项限制命令输出只能 报道行数。
6. head － 输出文件第一部分
7. tail - 输出文件最后一部分。 head 命令打印文件的前十行，而 tail 命令打印文件的后十行。默认情况下，两个命令 都打印十行文本，但是可以通过`-n`选项来调整命令打印的行数。也能用在管道线中：`ls /usr/bin | tail -n 5`
8. tail 有一个选项允许你实时地浏览文件。`tail -f /var/log/messages`。当观察日志文件的进展时，这很有用，因为 它们同时在被写入。使用`-f`选项，tail 命令继续监测这个文件，当新的内容添加到文件后，它们会立即 出现在屏幕上。这会一直继续下去直到你输入 `Ctrl-c`。
9. tee - 从标准输入读取数据，并同时写到标准输出和文件。tee 程序从标准输入读入数据，并且同时复制数据 到标准输出（允许数据继续随着管道线流动）和一个或多个文件。当在某个中间处理 阶段来捕捉一个管道线的内容时，这很有帮助。`ls /usr/bin | tee ls.txt | grep zip`
10. 像 ls 这样的程序实际上把他们的运行结果 输送到一个叫做标准输出的特殊文件（经常用 stdout 表示），而它们的状态信息则送到另一个 叫做标准错误输出的文件（stderr）。默认情况下，标准输出和标准错误输出都连接到屏幕，而不是 保存到磁盘文件。除此之外，许多程序从一个叫做标准输入（stdin）的设备得到输入，默认情况下， 标准输入连接到键盘。
11. I/O 重定向允许我们更改输出地点和输入来源。一般来说，输入来自键盘，输出送到屏幕， 但是通过 I/O 重定向，我们可以做出改变。
12. 标准输出重定向:I/O 重定向允许我们来重定义标准输出的地点。我们使用 `>` 重定向符后接文件名将标准输出重定向到除屏幕 以外的另一个文件。eg. `ls -l /usr/bin > ls-output.txt`
13. 如果我们需要清空一个文件内容（或者创建一个 新的空文件），可以使用这样的技巧：`> ls-output.txt`，即重新输出一个空文件。
14. 使用`>>`重定向符，把重定向结果追加到文件内容后面。类似 append。使用`>>`操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会 被创建，就如使用了`>`操作符。
15. 标准错误输出重定向:标准错误输出重定向没有专用的重定向操作符。为了重定向标准错误输出，我们必须用到其文件描述符。 一个程序的输出会流入到几个带编号的文件中。这些文件的前 三个称作标准输入、标准输出和标准错误输出，shell 内部分别将其称为文件描述符 0、1 和 2。shell 使用文件描述符提供 了一种表示法来重定向文件。因为标准错误输出和文件描述符 2 一样，我们用这种 表示法来重定向标准错误输出：`ls -l /bin/usr 2> ls-error.txt`，文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误输出到文件 ls-error.txt 任务。
16. 重定向标准输出和错误到同一个文件：
    - 传统的方法， 在旧版本 shell 中也有效：`ls -l /bin/usr > ls-output.txt 2>&1`注意重定向的顺序安排非常重要。标准错误输出的重定向必须总是出现在标准输出 重定向之后，要不然它不起作用。
    - 现在的 bash 版本提供了第二种方法，更精简合理的方法来执行这种联合的重定向。`ls -l /bin/usr &> ls-output.txt`
17. 处理不需要的输出:这种情况 尤其适用于错误和状态信息。具体做法是重定向输出结果到一个叫做”/dev/null”的特殊文件。这个文件是系统设备，叫做数字存储桶，它可以 接受输入，并且对输入不做任何处理。为了丢掉命令错误信息，我们这样做：`ls -l /bin/usr 2> /dev/null`
18. 标准输入重定向:`cat > test.txt`:创建一个文件并把键盘输入写入这个文件，如果该文件已存在，可能会把原来的内容覆盖。`cat < test.txt`:使用“<”重定向操作符，我们把标准输入源从键盘改到文件 test.txt，没啥意义。
19. 命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 功能所利用。 使用管道操作符`|`（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：`ls -l /usr/bin | less`
20. 管道线经常用来对数据完成复杂的操作。有可能会把几个命令放在一起组成一个管道线。 通常，以这种方式使用的命令被称为过滤器。过滤器接受输入，以某种方式改变它，然后 输出它。`ls /bin /usr/bin | sort | less`

#### echo

- `mkdir {2007..2009}-0{1..9} {2007..2009}-{10..12}`:快速生成以年月命名的文件夹
- 命令替换：命令替换允许我们把一个命令的输出作为另一个命令的一部分来使用：
  - `echo $(ls)`
  - `ls -l $(which cp)`:新版
  - "ls -l `which cp`":旧版
  - `file $(ls /usr/bin/* | grep zip)`:用于管道
  - 使用双引号，我们可以阻止单词分割，得到期望的结果；进一步，我们甚至可以修复 破损的文件名。
  - 在双引号中，参数展开、算术表达式展开和命令替换仍然有效：`echo "$USER $((2+2)) $(cal)"`
  - 如果需要禁止所有的展开，我们要使用单引号，原样打印字符串
  - 有时候我们只想引用单个字符。我们可以在字符之前加上一个反斜杠，在这里叫做转义字符。 经常在双引号中使用转义字符，来有选择地阻止展开。为了允许反斜杠字符出现，输入”\“来转义。注意在单引号中，反斜杠失去它的特殊含义，它 被看作普通字符。
  - echo 命令带上 `-e` 选项，能够解释转义序列。你可以把转义序列放在 `$' '` 里面。`sleep 10; echo -e "Time's up\a"`/`sleep 10; echo "Time's up" $'\a'`

#### 键盘高级操作技巧

1. clear － 清空屏幕
2. history － 显示历史列表内容
3. 光标移动命令
   |按键|行动|
   |--|--|
   |`Ctrl-a`| 移动光标到行首。|
   |`Ctrl-e`|移动光标到行尾。 |
   |`Ctrl-f`| 光标前移一个字符；和右箭头作用一样。|
   |`Ctrl-b`| 光标后移一个字符；和左箭头作用一样。|
   |`Alt-f`| 光标前移一个字。|
   |`Alt-b`| 光标后移一个字。|
   |`Ctrl-l`| 清空屏幕，移动光标到左上角。clear 命令完成同样的工作。|
4. 修改文本
   |按键| 行动|
   |--|--|
   |`Ctrl-d` |删除光标位置的字符。|
   |`Ctrl-t`|光标位置的字符和光标前面的字符互换位置。|
   |`Alt-t` |光标位置的字和其前面的字互换位置。|
   |`Alt-l` |把从光标位置到字尾的字符转换成小写字母。|
   |`Alt-u` |把从光标位置到字尾的字符转换成大写字母。|
5. 剪切和粘贴文本
   |按键| 行动|
   |--|--|
   |`Ctrl-k`| 剪切从光标位置到行尾的文本。|
   |`Ctrl-u` |剪切从光标位置到行首的文本。|
   |`Alt-d` |剪切从光标位置到词尾的文本。|
   |`Alt-Backspace`| 剪切从光标位置到词头的文本。如果光标在一个单词的开头，剪切前一个单词。|
   |`Ctrl-y` |把剪切环中的文本粘贴到光标位置。|
6. 自动补全命令
   |按键| 行动|
   |--|--|
   |`Alt-?`| 显示可能的自动补全列表。在大多数系统中，你也可以完成这个通过按 两次 tab 键，这会更容易些。|
   |`Alt-*`| 插入所有可能的自动补全。当你想要使用多个可能的匹配项时，这个很有帮助。|
7. `!<number>`: number 是这个命令在历史列表中的行号。我们可以使用另一种叫做 历史命令展开的方式，来调用「number」所代表的这一行命令：`!1102`。一个感叹号 ，其后再加上一个数字，可以把来自历史列表中的命令插入到命令行中。
8. 输入 Ctrl-r 来启动增量搜索， 接着输入你要寻找的字。当你找到它以后，你可以敲入 Enter 来执行命令， 或者输入 Ctrl-j，从历史列表中复制这一行到当前命令行。再次输入 Ctrl-r，来找到下一个 匹配项（历史列表中向上移动）。输入 Ctrl-g 或者 Ctrl-c，退出搜索。
9. 历史命令
   |按键| 行为|
   |--|--|
   |`Ctrl-p`| 移动到上一个历史条目。类似于上箭头按键。|
   |`Ctrl-n` |移动到下一个历史条目。类似于下箭头按键。|
   |`Alt-<` |移动到历史列表开头。|
   |`Alt->` |移动到历史列表结尾，即当前命令行。|
   |`Ctrl-r` |反向增量搜索。从当前命令行开始，向上增量搜索。|
   |`Alt-p` |反向搜索，非增量搜索。（输入要查找的字符串，按下 Enter 来执行搜索）。|
   | `Alt-n` |向前搜索，非增量。|
   |`Ctrl-o` |执行历史列表中的当前项，并移到下一个。如果你想要执行历史列表中一系列的命令，这很方便。|
10. 历史展开命令
    |序列| 行为|
    |--|--|
    |!! |重复最后一次执行的命令。可能按下上箭头按键和 enter 键更容易些。|
    |!number |重复历史列表中第 number 行的命令。|
    |!string |重复最近历史列表中，以这个字符串开头的命令。|
    |!?string| 重复最近历史列表中，包含这个字符串的命令。|

#### 权限

1. id – 显示用户身份号
2. chmod – 更改文件模式
3. chmod – 更改文件模式
4. su – 以另一个用户的身份来运行 shell
5. sudo – 以另一个用户的身份来执行命令
6. chown – 更改文件所有者
7. chgrp – 更改文件组所有权
8. passwd – 更改用户密码

####

####

####

####

####

#### echo

打印，输出。

1. `echo Hello World`打印 Hello World
2. `echo Hello World > file.txt`把 Hello World 输出到 file.text 中
3. `echo Hello World again >> file.txt`向 file.txt 中 append 一句 Hello World again
4. 打印空格要用`\ `或者`' '`

#### 变量

1. `foo=bar`:定义一个变量 foo，值是 bar。使用的时候有两种方式：`echo $foo`、`echo ${foo}`
2. 字符串插值：`echo 'Here is $foo'`或`echo 'Here is ${foo}'`

#### 命令替换

```bash
$ foo=$(echo bar)
$ echo "\$foo is $foo, but this gives us the same result: $(echo $foo)"
$foo is bar, but this gives us the same result: bar
```

#### 参数扩展技巧

语法 `${parameter:-word}` 允许您使用 word 作为默认值，以防 `$parameter` 未设置或为空

```bash
$ foo=${SOME_GLOBAL_VARIABLE:-default}
$ echo $foo
default
```

#### 退出代码

Bash 中没有布尔值，但命令 true 和 false 确实存在。他们不打印任何东西，但他们做了一些有用的事情：他们有不同的退出代码。

true 命令的退出代码为 0，按照惯例表示成功，而 false 命令的退出代码为 1，表示失败（非零）。

特殊参数 `$?`给我们最后执行的命令的退出代码。

#### 循环

大括号展开可以帮助我们生成一个动态的数字序列

```bash
for i in {0..9}; do
  echo "$i"
done
```

但是不可能使用像 `{0..$n}` 这样的东西，我们必须为此使用 seq 命令：

```bash
for i in $(seq 0 $(( n - 1))); do
  echo "$i"
done
```

#### 数组

```bash
$ fruits=(banana apple pear)
$ echo "The first fruit is ${fruits[0]}"
The first fruit is banana
$ echo "The last fruit is ${fruits[-1]}"
The last fruit is pear
$ for fruit in "${fruits[@]}"; do
>  echo "$fruit is a fruit"
> done
banana is a fruit
apple is a fruit
pear is a fruit
```

#### 关联数组

Bash 中的关联数组就像 JavaScript 对象，如果您选择将它们视为键值对集合。必须使用 `declare -A user` 来告诉 Bash 这个变量应该被视为一个关联数组，否则 Bash 将无法将它与简单的字符串数组区分开来。

```bash
$ declare -A user
$ user=(name "Phelipe Teles" age "26")
$ echo "user's name is ${user[name]}"
user's name is Phelipe Teles
$ for key in "${!user[@]}"; do echo "user's $key is ${user[$key]}"; done
user's age is 26
user's name is Phelipe Teles
```

示例：

```bash
n=15

for (( i=1; i <= n; i++ )); do
  if [[ $(( "$i" % 3 )) == 0 && $(( "$i" % 5 )) == 0 ]]; then
    echo "FizzBuzz"
  elif [[ $(( "$i" % 3 )) == 0 ]]; then
    echo "Fizz"
  elif [[ $(( "$i" % 5 )) == 0 ]]; then
    echo "Buzz"
  else
    echo "$i"
  fi
done
```

升级版

```bash
n=15

function is_divisible_by_3() {
  [[ $(( $1 % 3 )) == 0 ]]
}

function is_divisible_by_5() {
  [[ $(( $1 % 5 )) == 0 ]]
}

for (( i=1; i <= n; i++ )); do
  if is_divisible_by_3 "$i" && is_divisible_by_5 "$i"; then
    echo "FizzBuzz"
  elif is_divisible_by_3 "$i"; then
    echo "Fizz"
  elif is_divisible_by_5 "$i"; then
    echo "Buzz"
  else
    echo "$i"
  fi
done
```

#### return

Bash 确实有 return

#### 脚本

我们可以使用 chmod 命令授予当前用户执行文件的权限：

```bash
$ chmod u+x my-script.sh
$ ./my-script.sh
Hello World
```

#### example

```bash
read -p "Insert a non-negative integer, please: " n

function is_divisible_by_3() {
  [[ $(( $1 % 3 )) == 0 ]]
}

function is_divisible_by_5() {
  [[ $(( $1 % 3 )) == 0 ]]
}

for (( i=1; i <= $n; i++ )); do
  if is_divisible_by_3 $i && is_divisible_by_5 $i; then
    echo "FizzBuzz"
  elif is_divisible_by_3 $i; then
    echo "Fizz"
  elif is_divisible_by_5 $i; then
    echo "Buzz"
  else
    echo "$i"
  fi
done
```

#### 信号

在我们的脚本被打断之前，我们可能想做一些事情。

如果我们希望以不同的方式处理这个信号，我们可以使用 trap 内置命令。

```bash
#!/bin/bash
function close() {
  echo "Ok. Bye :)"
  exit 0
}

trap "close" "SIGINT"

while true; do
  echo "Loading..."
  sleep 1
done
```

信号是 Unix 系统中非常重要的组成部分，它是进程之间相互通信的方式。

还有更多，例如，类似于 SIGINT 的其他一些是 SIGTERM 要求进程终止， SIGKILL 硬杀死进程 - 立即杀死它并且程序无法以不同的方式处理它。

#### 管道

管道是我们组合命令来完成任务的一种方式。它通过将前一个命令的标准输出作为标准输入传递给管道中的下一个命令来工作。

```bash
$ echo "Apple,Oranges,Pear" | cut -d, -f 2
Oranges
```
