(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{758:function(a,s,n){"use strict";n.r(s);var e=n(7),t=Object(e.a)({},(function(){var a=this,s=a.$createElement,n=a._self._c||s;return n("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[n("h2",{attrs:{id:"包管理工具知识"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#包管理工具知识"}},[a._v("#")]),a._v(" 包管理工具知识")]),a._v(" "),n("p",[a._v("PackageManageTools.md")]),a._v(" "),n("h2",{attrs:{id:"现有包管理工具中-node-modules-存在的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#现有包管理工具中-node-modules-存在的问题"}},[a._v("#")]),a._v(" 现有包管理工具中 node_modules 存在的问题")]),a._v(" "),n("h3",{attrs:{id:"node-modules-安装方式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#node-modules-安装方式"}},[a._v("#")]),a._v(" node_modules 安装方式")]),a._v(" "),n("p",[a._v("目前有两种安装方式："),n("code",[a._v("Nested installation")]),a._v("、"),n("code",[a._v("Flat installation")])]),a._v(" "),n("h4",{attrs:{id:"nested-installation-嵌套安装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#nested-installation-嵌套安装"}},[a._v("#")]),a._v(" Nested installation 嵌套安装")]),a._v(" "),n("p",[a._v("在 npm@3 之前，node_modules 结构是干净、可预测的，因为 node_modules 中的每个依赖项都有自己的 node_modules 文件夹，在 package.json 中指定了所有依赖项。即层层嵌套。")]),a._v(" "),n("p",[a._v("有两个严重的问题：")]),a._v(" "),n("ol",[n("li",[a._v("package 中经常创建太深的依赖树，这会导致 Windows 上的目录路径过长问题。")]),a._v(" "),n("li",[a._v("当一个 package 在不同的依赖项中需要时，它会被多次复制粘贴并生成多份文件。")])]),a._v(" "),n("h4",{attrs:{id:"flat-installation-扁平安装"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#flat-installation-扁平安装"}},[a._v("#")]),a._v(" Flat installation 扁平安装")]),a._v(" "),n("p",[a._v("在 npm@3+ 和 yarn 中，node_modules 结构变成扁平化结构。在 hoist 机制下，某些包会被提升到顶层（至于哪个版本的包被提升，依赖于包的安装顺序！），如果同一个包的多个版本在项目中被依赖时，多个版本的包只能有一个被提升上来，其余版本的包会嵌套安装到各自的依赖当中（类似 npm2 的结构）。依赖变更会影响提升的版本号。")]),a._v(" "),n("h3",{attrs:{id:"npm3-和-yarn-存在的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#npm3-和-yarn-存在的问题"}},[a._v("#")]),a._v(" npm3+和 yarn 存在的问题")]),a._v(" "),n("h4",{attrs:{id:"phantom-dependencies-幽灵依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#phantom-dependencies-幽灵依赖"}},[a._v("#")]),a._v(" Phantom dependencies 幽灵依赖")]),a._v(" "),n("p",[a._v("Phantom dependencies 被称之为幽灵依赖或幻影依赖，解释起来很简单，即某个包没有在 package.json 被依赖，但是用户却能够引用到这个包。")]),a._v(" "),n("p",[a._v("引发这个现象的原因一般是因为 node_modules 结构所导致的。例如使用 npm 或 yarn 对项目安装依赖，依赖里面有个依赖叫做 foo，foo 这个依赖同时依赖了 bar，yarn 会对安装的 node_modules 做一个扁平化结构的处理，会把依赖在 node_modules 下打平，这样相当于 foo 和 bar 出现在同一层级下面。那么根据 nodejs 的寻径原理，用户能 require 到 foo，同样也能 require 到 bar。")]),a._v(" "),n("div",{staticClass:"language-txt line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-txt"}},[n("code",[a._v("nodejs的寻址方式：\n\n1. 对于核心模块（core module） => 绝对路径 寻址\n\n2. node标准库 => 相对路径寻址\n\n3. 第三方库（通过npm安装）到node_modules下的库：\n\n   3.1   先在当前路径下，寻找 node_modules/xxx\n   3.2    递归从下往上到上级路径，寻找 ../node_modules/xxx\n   3.3    循环第二步\n   3.4    在全局环境路径下寻找 .node_modules/xxx\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br")])]),n("h4",{attrs:{id:"npm-doppelgangers-npm-分身"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#npm-doppelgangers-npm-分身"}},[a._v("#")]),a._v(" NPM doppelgangers NPM 分身")]),a._v(" "),n("p",[a._v("这个问题其实也可以说是 hoist 导致的，这个问题可能会导致有大量的依赖的被重复安装。")]),a._v(" "),n("p",[a._v("在 npm2 时，结构如下:")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("- package A\n    - packageX 1.0\n    - packageY 1.0\n- package B\n    - packageX 2.0\n    - packageY 2.0\n- package C\n    - packageX 1.0\n    - packageY 2.0\n- package D\n    - packageX 2.0\n    - packageY 1.0\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br"),n("span",{staticClass:"line-number"},[a._v("12")]),n("br")])]),n("p",[a._v("在 npm3+和 yarn 中，由于存在 hoist 机制，所以 X 和 Y 各有一个版本被提升了上来，目录结构如下:")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v("- package X => 1.0版本\n- package Y => 1.0版本\n\n- package A\n- package B\n    - packageX 2.0\n    - packageY 2.0\n- package C\n    - packageY 2.0\n- package D\n    - packageX 2.0\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br"),n("span",{staticClass:"line-number"},[a._v("8")]),n("br"),n("span",{staticClass:"line-number"},[a._v("9")]),n("br"),n("span",{staticClass:"line-number"},[a._v("10")]),n("br"),n("span",{staticClass:"line-number"},[a._v("11")]),n("br")])]),n("p",[a._v("如上图所示的 packageX 2.0 和 packageY 2.0 被重复安装多次，从而造成 npm 和 yarn 的性能一些性能损失。")]),a._v(" "),n("p",[a._v("这种场景在 monorepo 多包场景下尤其明显，这也是 yarn workspace 经常被吐槽的点，另外扁平化的算法实现也相当复杂，改动成本很高。")]),a._v(" "),n("h3",{attrs:{id:"pnpm-的破解之道-网状-平铺的-node-modules-结构"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-的破解之道-网状-平铺的-node-modules-结构"}},[a._v("#")]),a._v(" pnpm 的破解之道：网状 + 平铺的 node_modules 结构")]),a._v(" "),n("p",[a._v("pnpm 项目的 node_modules 并不是扁平化结构，而是目录树的结构，类似 npm version 2.x 版本中的结构。同时还有个.pnpm 目录，.pnpm 以平铺的形式储存着所有的包，正常的包都可以在这种命名模式的文件夹中被找到（peerDep 例外）：")]),a._v(" "),n("div",{staticClass:"language-bash line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-bash"}},[n("code",[a._v(".pnpm/"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("organization-name"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("+"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("package-name"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("@"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("version"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("/node_modules/"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v("name"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v(">")]),a._v("\n\n// 组织名"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("若无会省略"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("+包名@版本号/node_modules/名称"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("项目名称"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br")])]),n("p",[a._v("我们称.pnmp 为"),n("strong",[a._v("虚拟存储目录")]),a._v("，该目录通过"),n("code",[a._v("<package-name>@<version>")]),a._v("来实现相同模块不同版本之间隔离和复用，由于它只会根据项目中的依赖生成，并不存在提升，所以它不会存在之前提到的 Phantom dependencies 问题！")]),a._v(" "),n("h3",{attrs:{id:"pnpm-如何跟文件资源进行关联的-又如何被项目中使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-如何跟文件资源进行关联的-又如何被项目中使用"}},[a._v("#")]),a._v(" pnpm 如何跟文件资源进行关联的? 又如何被项目中使用?")]),a._v(" "),n("p",[a._v("答案是"),n("strong",[a._v("Store + Links")]),a._v("！")]),a._v(" "),n("h4",{attrs:{id:"store"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#store"}},[a._v("#")]),a._v(" Store")]),a._v(" "),n("p",[a._v("pnpm 资源在磁盘上的存储位置。")]),a._v(" "),n("p",[n("code",[a._v("pnpm 使用名为 .pnpm-store的 store dir，Mac/linux中默认会设置到{home dir}>/.pnpm-store/v3；windows下会设置到当前盘的根目录下，比如C（C/.pnpm-store/v3）、D盘（D/.pnpm-store/v3）")]),a._v("。")]),a._v(" "),n("p",[a._v("具体可以参考  @pnpm/store-path  这个 pnpm 子包中的代码:")]),a._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("const")]),a._v(" homedir "),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" os"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("homedir")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("await")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("canLinkToSubdir")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("tempFile"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" homedir"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("await")]),a._v(" fs"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("unlink")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("tempFile"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// If the project is on the drive on which the OS home directory")]),a._v("\n\t"),n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// then the store is placed in the home directory")]),a._v("\n\t"),n("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" path"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),n("span",{pre:!0,attrs:{class:"token function"}},[a._v("join")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("homedir"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" relStore"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" "),n("span",{pre:!0,attrs:{class:"token constant"}},[a._v("STORE_VERSION")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br"),n("span",{staticClass:"line-number"},[a._v("4")]),n("br"),n("span",{staticClass:"line-number"},[a._v("5")]),n("br"),n("span",{staticClass:"line-number"},[a._v("6")]),n("br"),n("span",{staticClass:"line-number"},[a._v("7")]),n("br")])]),n("p",[n("code",[a._v("由于每个磁盘有自己的存储方式，所以Store会根据磁盘来划分。 如果磁盘上存在主目录，存储则会被创建在 <home dir>/.pnpm-store；如果磁盘上没有主目录，那么将在文件系统的根目录中创建该存储。 例如，如果安装发生在挂载在 /mnt 的文件系统上，那么存储将在 /mnt/.pnpm-store 处创建。 Windows系统上也是如此。")])]),a._v(" "),n("p",[a._v("可以在不同的磁盘上设置同一个存储，但在这种情况下，pnpm 将"),n("strong",[a._v("复制包")]),a._v("而不是硬链接它们，因为"),n("strong",[a._v("硬链接只能发生在同一文件系统同一分区上")]),a._v(".")]),a._v(" "),n("p",[a._v("pnpm install 的安装过程中，我们会看到如下的信息，这个里面的 Content-addressable store 就是我们目前说的 Store.")]),a._v(" "),n("ul",[n("li",[a._v("CAS 内容寻址存储，是一种存储信息的方式，根据内容而不是位置进行检索信息的存储方式.")]),a._v(" "),n("li",[a._v("Virtual store 虚拟存储，指向存储的链接的目录，所有直接和间接依赖项都链接到此目录中，项目当中的.pnpm 目录.")])]),a._v(" "),n("p",[a._v("区别对比：如果是 npm 或 yarn，那么这个依赖在多个项目中使用，在每次安装的时候都会被重新下载一次；而在使用 pnpm 对项目安装依赖的时候，如果某个依赖在 sotre 目录中存在了话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。")]),a._v(" "),n("p",[a._v("如果安装了很多很多不同的依赖，那么 store 目录也会越来越大，可以通过"),n("code",[a._v("pnpm store prune")]),a._v("部分解决这个问题。它提供了一种用于删除一些不被全局项目所引用到的 packages 的功能。该命令推荐偶尔进行使用，但不要频繁使用，因为可能某天这个不被引用的包又突然被哪个项目引用了，这样就可以不用再去重新下载这个包了。")]),a._v(" "),n("h4",{attrs:{id:"links-hard-link-symbolic-link"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#links-hard-link-symbolic-link"}},[a._v("#")]),a._v(" Links（hard link & symbolic link）")]),a._v(" "),n("ol",[n("li",[a._v("hard link")])]),a._v(" "),n("p",[a._v("pnpm 是怎么做到如此大的性能提升的？一部分原因是使用了计算机当中的 Hard link ，它减少了文件下载的数量，从而提升了下载和响应速度。")]),a._v(" "),n("p",[a._v("通过 hard link，  用户可以通过不同的路径引用方式去找到某个文件，需要注意的是一般用户权限下只能硬链接到文件，不能用于目录。")]),a._v(" "),n("p",[a._v("pnpm 会在 Store(上面的 Store) 目录里存储项目  node_modules  文件的  hard links ，通过访问这些 link 直接访问文件资源。因为这样一个机制，导致每次安装依赖的时候，如果是个相同的依赖，有好多项目都用到这个依赖，那么这个依赖实际上最优情况(即版本相同)只用安装一次。")]),a._v(" "),n("p",[n("strong",[a._v("通过 Store + hard link 的方式，不仅解决了项目中的 NPM doppelgangers 问题，项目之间也不存在该问题，从而完美解决了 npm3+和 yarn 中的包重复问题！")])]),a._v(" "),n("ol",{attrs:{start:"2"}},[n("li",[a._v("symbolic link")])]),a._v(" "),n("p",[a._v("由于 hark link 只能用于文件不能用于目录，但是 pnpm 的 node_modules 是树形目录结构，那么如何链接到文件？ 通过 symbolic link（也可称之为软链或者符号链接）来实现！")]),a._v(" "),n("p",[a._v("pnpm 在全局通过 Store 来存储所有的 node_modules 依赖，并且在.pnpm/node_modules 中存储项目的 hard links，通过 hard link 来链接真实的文件资源，项目中则通过 symbolic link 链接到.pnpm/node_modules 目录中，"),n("strong",[a._v("依赖放置在同一级别避免了循环的软链")]),a._v("。")]),a._v(" "),n("h4",{attrs:{id:"peerdependencies-相对依赖"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#peerdependencies-相对依赖"}},[a._v("#")]),a._v(" PeerDependencies 相对依赖")]),a._v(" "),n("p",[a._v("pnpm 的最佳特征之一是，在一个项目中，"),n("code",[a._v("package")]),a._v("的一个特定版本将始终只有一组依赖项。 这个规则有一个例外 -那就是具有 [peer dependencies ]。通常，如果一个 package 没有 peer 依赖项（peer dependencies），它会被硬链接到其依赖项的软连接（symlinks）旁的 node_modules。")]),a._v(" "),n("p",[a._v("peerDep 的包命名规则如下：")]),a._v(" "),n("div",{staticClass:"language- line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[a._v(".pnpm/<organization-name>+<package-name>@<version>_<organization-name>+<package-name>@<version>/node_modules/<name>\n\n// peerDep组织名(若无会省略)+包名@版本号_组织名(若无会省略)+包名@版本号/node_modules/名称(项目名称)\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br"),n("span",{staticClass:"line-number"},[a._v("3")]),n("br")])]),n("p",[a._v("如果一个 package 没有 peer 依赖（peer dependencies），不过它的依赖项有 peer 依赖，这些依赖会在更高的依赖图中解析, 则这个传递 package 便可在项目中有几组不同的依赖项。 例如，a@1.0.0  具有单个依赖项  b@1.0.0。 b@1.0.0  有一个 peer 依赖为  c@^1。 a@1.0.0  永远不会解析b@1.0.0的 peer, 所以它也会依赖于  b@1.0.0  的 peer 。如果需要解决 peerDep 引入的多实例问题，可以通过 .pnpmfile.cjs 文件更改依赖项的依赖关系。")]),a._v(" "),n("h2",{attrs:{id:"pnpm-和-npm、yarn-的功能差异"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-和-npm、yarn-的功能差异"}},[a._v("#")]),a._v(" pnpm 和 npm、yarn 的功能差异")]),a._v(" "),n("table",[n("thead",[n("tr",[n("th",[a._v("功能")]),a._v(" "),n("th",[a._v("pnpm")]),a._v(" "),n("th",[a._v("yarn")]),a._v(" "),n("th",[a._v("npm")])])]),a._v(" "),n("tbody",[n("tr",[n("td",[a._v("工作空间支持（monorepo）")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️")])]),a._v(" "),n("tr",[n("td",[a._v("隔离的  node_modules")]),a._v(" "),n("td",[a._v("✔️ - 默认")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️")])]),a._v(" "),n("tr",[n("td",[a._v("提升的  node_modules")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️ - 默认")])]),a._v(" "),n("tr",[n("td",[a._v("Plug'n'Play")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️ - 默认")]),a._v(" "),n("td",[a._v("❌")])]),a._v(" "),n("tr",[n("td",[a._v("零安装")]),a._v(" "),n("td",[a._v("❌")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("❌")])]),a._v(" "),n("tr",[n("td",[a._v("修补依赖项")]),a._v(" "),n("td",[a._v("❌")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("❌")])]),a._v(" "),n("tr",[n("td",[a._v("管理 Node.js 版本（pnpm 独有）")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("❌")]),a._v(" "),n("td",[a._v("❌")])]),a._v(" "),n("tr",[n("td",[a._v("有锁文件")]),a._v(" "),n("td",[a._v("✔️ - pnpm-lock.yaml")]),a._v(" "),n("td",[a._v("✔️ - yarn.lock")]),a._v(" "),n("td",[a._v("✔️ - package-lock.json")])]),a._v(" "),n("tr",[n("td",[a._v("支持覆盖")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("✔️ - 通过 resolutions")]),a._v(" "),n("td",[a._v("✔️")])]),a._v(" "),n("tr",[n("td",[a._v("内容可寻址存储(CAS)（pnpm 独有）")]),a._v(" "),n("td",[a._v("✔️")]),a._v(" "),n("td",[a._v("❌")]),a._v(" "),n("td",[a._v("❌")])]),a._v(" "),n("tr",[n("td",[a._v("动态包执行")]),a._v(" "),n("td",[a._v("✔️ - 通过  pnpm dlx")]),a._v(" "),n("td",[a._v("✔️ - 通过  yarn dlx")]),a._v(" "),n("td",[a._v("✔️ - 通过  npx")])])])]),a._v(" "),n("p",[a._v("pnpm 独有的实现：1.管理 Node.js 版本和 2.内容可寻址存储(CAS).")]),a._v(" "),n("ol",[n("li",[n("p",[a._v("参考上面.")])]),a._v(" "),n("li",[n("p",[a._v("这个在.npmrc 文件中，Node 模块设置中使用 use-node-version 进行配置.")])])]),a._v(" "),n("p",[a._v("use-node-version 用于指定应用于项目运行时的确切 Node.js 版本，支持 semver 版本设置。设置后， pnpm 将自动安装指定版本的 Node.js 并将其用于执行 pnpm run 命令或 pnpm node 命令。例：")]),a._v(" "),n("div",{staticClass:"language-js line-numbers-mode"},[n("pre",{pre:!0,attrs:{class:"language-js"}},[n("code",[n("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 指定版本16.x")]),a._v("\nuse"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("node"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),a._v("version"),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),n("span",{pre:!0,attrs:{class:"token operator"}},[a._v("^")]),n("span",{pre:!0,attrs:{class:"token number"}},[a._v("16")]),n("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("x\n")])]),a._v(" "),n("div",{staticClass:"line-numbers-wrapper"},[n("span",{staticClass:"line-number"},[a._v("1")]),n("br"),n("span",{staticClass:"line-number"},[a._v("2")]),n("br")])]),n("h3",{attrs:{id:"pnpm-命令"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pnpm-命令"}},[a._v("#")]),a._v(" pnpm 命令")]),a._v(" "),n("ol",[n("li",[a._v("pnpm add 安装 package 以及依赖的 package，默认是安装到 dependencies 中。注意的是在 workspace 中，如果想要安装在 root workspace 中需要添加-w 或者--ignore-workspace-root-check，安装到 packages 中需要使用--filter，否则会安装失败。")]),a._v(" "),n("li",[a._v("pnpm remove 别名: rm, uninstall, un。从 node_modules 和项目的 package.json 中移除包。")]),a._v(" "),n("li",[a._v("pnpm install 别名: i。用于安装项目所有依赖。在 CI 环境中, 如果存在需要更新的 lockfile 会安装失败，所以每次版本更新后，本地一定要 install 后再提交，否则会导致版本发布失败。")]),a._v(" "),n("li",[a._v("pnpm import 命令支持从其它格式的 lock 文件生成 pnpm-lock.yaml 文件。")]),a._v(" "),n("li",[a._v("pnpm prune 移除项目中不需要的依赖包，配置项支持 --prod(删除在 devDependencies 中指定的包)和 --no-optional(删除在 optionalDependencies 中指定的包。)。")]),a._v(" "),n("li",[a._v("pnpm list 别名: ls。此命令会以一个树形结构输出所有的已安装 package 的版本及其依赖。添加参数--json 后会输出 JSON 格式的日志。")]),a._v(" "),n("li",[a._v("pnpm run 别名: run-script。运行一个在 package 的 manifest 文件中定义的脚本。")])]),a._v(" "),n("h2",{attrs:{id:"有用的第三方库"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#有用的第三方库"}},[a._v("#")]),a._v(" 有用的第三方库")]),a._v(" "),n("ol",[n("li",[n("code",[a._v('"@ianvs/prettier-plugin-sort-imports": "4.1.1"')])])])])}),[],!1,null,null,null);s.default=t.exports}}]);