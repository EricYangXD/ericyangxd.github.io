(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{746:function(v,_,t){"use strict";t.r(_);var s=t(8),a=Object(s.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h2",{attrs:{id:"redis-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-是什么"}},[v._v("#")]),v._v(" Redis 是什么")]),v._v(" "),t("h2",{attrs:{id:"redis-用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-用法"}},[v._v("#")]),v._v(" Redis 用法")]),v._v(" "),t("h2",{attrs:{id:"redis-的优缺点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-的优缺点"}},[v._v("#")]),v._v(" Redis 的优缺点")]),v._v(" "),t("h2",{attrs:{id:"redis-的使用场景"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-的使用场景"}},[v._v("#")]),v._v(" Redis 的使用场景")]),v._v(" "),t("h2",{attrs:{id:"redis-的几种模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#redis-的几种模式"}},[v._v("#")]),v._v(" Redis 的几种模式")]),v._v(" "),t("h3",{attrs:{id:"主从模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从模式"}},[v._v("#")]),v._v(" 主从模式")]),v._v(" "),t("p",[v._v("主从模式（Master-Slave）是指在 Redis 中有一个主节点（Master）和一个或多个从节点（Slave）。主节点负责所有的写操作和读操作，而从节点负责复制主节点的数据，并可以处理读操作。多个从节点可以存在于一个主节点之下，以实现负载均衡和冗余。")]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("ul",[t("li",[v._v("数据同步：从节点会定期从主节点获取数据快照（RDB）或增量数据（AOF），保持数据一致。")]),v._v(" "),t("li",[v._v("读写分离：可以通过将读请求分发给从节点，从而减轻主节点的压力，提高系统的读性能。")]),v._v(" "),t("li",[v._v("简单：主从模式的设置与管理相对简单，适合对高可用性要求不高的场景。")])]),v._v(" "),t("p",[v._v("如何工作：")]),v._v(" "),t("ul",[t("li",[v._v("主节点的任何写操作都会同步到所有从节点。")]),v._v(" "),t("li",[v._v("从节点可以在不影响主节点的情况下处理读请求。")]),v._v(" "),t("li",[v._v("如果主节点宕机，从节点将无法自动提升为主节点。")])]),v._v(" "),t("h3",{attrs:{id:"哨兵模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#哨兵模式"}},[v._v("#")]),v._v(" 哨兵模式")]),v._v(" "),t("p",[v._v("哨兵模式（Sentinel）是 Redis 提供的一种高可用性解决方案。哨兵不仅监控主从节点的状态，还可以在主节点宕机时自动进行故障转移（failover），并选举新的主节点。")]),v._v(" "),t("p",[v._v("特点：")]),v._v(" "),t("ul",[t("li",[v._v("高可用性：通过哨兵监控 Redis 实例，能够实现自动故障转移，确保系统的高可用性。")]),v._v(" "),t("li",[v._v("监控：哨兵会定期检查主节点和从节点的状态，能够及时发现故障。")]),v._v(" "),t("li",[v._v("通知：哨兵能够通过 API 通知客户端关于服务器状态的变化。")]),v._v(" "),t("li",[v._v("配置管理：哨兵可以动态管理 Redis 集群的主从关系，无需手动干预。")])]),v._v(" "),t("p",[v._v("如何工作：")]),v._v(" "),t("ul",[t("li",[v._v("哨兵会持续监控主节点和从节点的健康状态。")]),v._v(" "),t("li",[v._v("当哨兵检测到主节点宕机时，会启动故障转移过程，选举一个可用的从节点提升为新的主节点。")]),v._v(" "),t("li",[v._v("更新配置后，其他从节点会自动重新配置为新的主节点。")])]),v._v(" "),t("h3",{attrs:{id:"主从模式与哨兵模式的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#主从模式与哨兵模式的区别"}},[v._v("#")]),v._v(" 主从模式与哨兵模式的区别")]),v._v(" "),t("table",[t("thead",[t("tr",[t("th",[v._v("特点")]),v._v(" "),t("th",[v._v("主从模式")]),v._v(" "),t("th",[v._v("哨兵模式")])])]),v._v(" "),t("tbody",[t("tr",[t("td",[v._v("主要功能")]),v._v(" "),t("td",[v._v("数据复制与读写分离")]),v._v(" "),t("td",[v._v("监控、故障转移和高可用性")])]),v._v(" "),t("tr",[t("td",[v._v("故障处理")]),v._v(" "),t("td",[v._v("无自动故障转移")]),v._v(" "),t("td",[v._v("自动故障转移")])]),v._v(" "),t("tr",[t("td",[v._v("结构")]),v._v(" "),t("td",[v._v("只有主节点和从节点")]),v._v(" "),t("td",[v._v("包含哨兵节点、主节点和从节点")])]),v._v(" "),t("tr",[t("td",[v._v("数据一致性")]),v._v(" "),t("td",[v._v("数据同步，主从一致")]),v._v(" "),t("td",[v._v("故障转移后可能存在短暂的不一致")])]),v._v(" "),t("tr",[t("td",[v._v("复杂性")]),v._v(" "),t("td",[v._v("简单，配置容易")]),v._v(" "),t("td",[v._v("复杂，需要配置哨兵节点")])])])]),v._v(" "),t("ul",[t("li",[v._v("主从模式适合数据复制和读写分离的场景，但在高可用性上存在局限性。")]),v._v(" "),t("li",[v._v("哨兵模式提供了更全面的高可用解决方案，能够自动处理故障转移，适合对系统稳定性要求较高的应用场景。")])]),v._v(" "),t("p",[v._v("总结：所以哨兵模式就是在主从模式的基础上加了个哨兵节点，用于自动故障转移+保证高可用性，然后主从节点还是跟主从模式一样，主节点负责所有的写操作和读操作，而从节点负责复制主节点的数据，并可以处理读操作。")])])}),[],!1,null,null,null);_.default=a.exports}}]);