(window.webpackJsonp=window.webpackJsonp||[]).push([[137],{812:function(e,_,v){"use strict";v.r(_);var a=v(7),i=Object(a.a)({},(function(){var e=this,_=e.$createElement,v=e._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h2",{attrs:{id:"tree-shaking-定义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tree-shaking-定义"}},[e._v("#")]),e._v(" Tree Shaking 定义")]),e._v(" "),v("ul",[v("li",[e._v("利用 ES Module 可以进行静态分析的特点来检测模块内容的导出、导入以及被使用的情况，保留 Live Code。")]),e._v(" "),v("li",[e._v("Rollup 对 Tree-shaking 的定义已经不仅仅是 ES Module 相关，此外它还支持了 DCE -- 消除不会被执行和没有副作用（Side Effect） 的 Dead Code，即 DCE 过程。")]),e._v(" "),v("li",[e._v("Tree Shaking 指基于 ES Module 进行静态分析，通过 AST 将用不到的函数进行移除，从而减小打包体积。")]),e._v(" "),v("li",[e._v("与代码压缩不同，代码压缩主要是移除模块内部的无效代码，而 Tree Shaking 则是移除模块之间未使用的导出。")])]),e._v(" "),v("h3",{attrs:{id:"原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#原理"}},[e._v("#")]),e._v(" 原理")]),e._v(" "),v("ul",[v("li",[e._v("ESM 要求所有的导入导出语句只能出现在模块顶层，且导入导出的模块名必须为字符串常量，所以，ESM 下模块之间的依赖关系是高度确定的，与运行状态无关，编译工具只需要对 ESM 模块做静态分析，就可以从代码字面量中推断出哪些模块值未曾被其它模块使用，这是实现 Tree Shaking 技术的必要条件。")]),e._v(" "),v("li",[e._v("webpack5 已经自带了这个功能了，当打包环境为 "),v("code",[e._v("production: true")]),e._v(" 时，默认开启 "),v("code",[e._v("tree-shaking")]),e._v(" 功能。")])]),e._v(" "),v("h3",{attrs:{id:"在-webpack-中实现-tree-shaking-的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在-webpack-中实现-tree-shaking-的原理"}},[e._v("#")]),e._v(" 在 Webpack 中实现 Tree Shaking 的原理")]),e._v(" "),v("p",[e._v("Webpack 中，Tree-shaking 的实现一是「先标记出模块导出值中哪些没有被用过」，二是「使用 Terser、UglifyJS 等 DCE 工具删掉这些没被用到的导出语句」。标记过程大致可划分为三个步骤：")]),e._v(" "),v("ol",[v("li",[e._v("Make （构建）阶段，收集模块导出变量并记录到模块依赖关系图 ModuleGraph 变量中")]),e._v(" "),v("li",[e._v("Seal （封装阶段），遍历 ModuleGraph 标记模块导出变量有没有被使用")]),e._v(" "),v("li",[e._v("生成产物时，若变量没有被其它模块使用则删除对应的导出语句")])]),e._v(" "),v("h3",{attrs:{id:"详细一点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#详细一点"}},[e._v("#")]),e._v(" 详细一点")]),e._v(" "),v("p",[e._v("Webpack 中 Tree Shaking 的实现分为如下步骤：")]),e._v(" "),v("ul",[v("li",[e._v("在 "),v("code",[e._v("FlagDependencyExportsPlugin")]),e._v(" 插件中根据模块的 dependencies 列表收集模块导出值，并记录到 ModuleGraph 体系的 "),v("code",[e._v("exportsInfo")]),e._v(" 中；")]),e._v(" "),v("li",[e._v("在 "),v("code",[e._v("FlagDependencyUsagePlugin")]),e._v(" 插件中收集模块的导出值的使用情况，并记录到 "),v("code",[e._v("exportInfo._usedInRuntime")]),e._v(" 集合中；")]),e._v(" "),v("li",[e._v("在 "),v("code",[e._v("HarmonyExportXXXDependency.Template.apply")]),e._v(" 方法中根据导出值的使用情况生成不同的导出语句；")]),e._v(" "),v("li",[e._v("使用 DCE（Terser、UglifyJS 等）工具删除 Dead Code，实现完整的树摇效果。")])]),e._v(" "),v("h2",{attrs:{id:"使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用"}},[e._v("#")]),e._v(" 使用")]),e._v(" "),v("ol",[v("li",[e._v("使用>= ES2015 模块语法（即 import 和 export）")]),e._v(" "),v("li",[e._v("确保没有编译器将 ES2015 模块语法转换为 CommonJS 的（这是现在常用的@babel/preset-env 的默认行为）")]),e._v(" "),v("li",[e._v("在项目的 package.json 文件中，添加"),v("code",[e._v('"sideEffects": "false"')]),e._v("属性")]),e._v(" "),v("li",[e._v("使用 "),v("code",[e._v('mode: "production"')]),e._v("的配置项以启用更多优化项，包括压缩代码与 tree shaking")])]),e._v(" "),v("h3",{attrs:{id:"在-webpack-中启动-tree-shaking"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#在-webpack-中启动-tree-shaking"}},[e._v("#")]),e._v(" 在 Webpack 中启动 Tree Shaking")]),e._v(" "),v("p",[e._v("在 Webpack 中，启动 Tree Shaking 功能必须同时满足三个条件：")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("使用 ESM 规范编写模块代码 - 绝对的大前提")])]),e._v(" "),v("li",[v("p",[e._v("配置 "),v("code",[e._v("optimization.usedExports = true")]),e._v("，启动标记功能 -（在开发环境启动 Tree Shaking）")])]),e._v(" "),v("li",[v("p",[e._v("启动代码优化功能，可以通过如下方式实现：")]),e._v(" "),v("ul",[v("li",[e._v("配置 "),v("code",[e._v("mode = production")]),e._v(" - 在 Webpack5 中，Tree Shaking 在生产环境下默认启动")]),e._v(" "),v("li",[e._v("配置 "),v("code",[e._v("optimization.minimize = true")]),e._v(" -（在开发环境启动 Tree Shaking）")]),e._v(" "),v("li",[e._v("提供 "),v("code",[e._v("optimization.minimizer")]),e._v(" 数组 -（在开发环境启动 Tree Shaking）")])])])]),e._v(" "),v("h2",{attrs:{id:"tips-实践"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tips-实践"}},[e._v("#")]),e._v(" tips 实践")]),e._v(" "),v("ol",[v("li",[e._v("当使用语法 "),v("code",[e._v("import *")]),e._v(" 时，Tree Shaking 依然生效。")]),e._v(" "),v("li",[e._v("Tree Shaking 甚至可对 JSON 进行优化。原理是因为 JSON 格式简单，通过 AST 容易预测结果，不像 JS 对象有复杂的类型与副作用。")]),e._v(" "),v("li",[e._v("为了减小生产环境体积，我们可以使用一些支持 ES 的 package，比如使用 "),v("code",[e._v("lodash-es")]),e._v("/"),v("code",[e._v("babel-plugin-lodash")]),e._v(" 替代 "),v("code",[e._v("lodash")]),e._v("。")]),e._v(" "),v("li",[e._v("我们可以在 "),v("a",{attrs:{href:"//npm.devtool.tech"}},[e._v("npm.devtool.tech")]),e._v(" (opens new window)中查看某个库是否支持 Tree Shaking。")]),e._v(" "),v("li",[e._v("使用 "),v("code",[e._v("/*#__PURE__*/")]),e._v(" 标注纯函数调用：在调用语句前添加 "),v("code",[e._v("/*#__PURE__*/")]),e._v(" 备注，明确告诉 Webpack 该次函数调用并不会对上下文环境产生副作用")]),e._v(" "),v("li",[e._v("禁止 Babel 转译模块导入导出语句：Babel 可以将 "),v("code",[e._v("import/export")]),e._v(" 风格的 ESM 语句等价转译为 CommonJS 风格的模块化语句，但该功能却导致 Webpack 无法对转译后的模块导入导出内容做静态分析")]),e._v(" "),v("li",[e._v("优化导出值的粒度：比如 default 导出了一个包含多个属性/值的对象，即使实际上只用到导出值的其中一个属性，整个 default 对象依然会被完整保留。所以实际开发中，应该尽量保持导出值颗粒度和原子性")]),e._v(" "),v("li",[e._v("避免无意义的赋值，原因参考缺陷如下")])]),e._v(" "),v("h2",{attrs:{id:"缺陷"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺陷"}},[e._v("#")]),e._v(" 缺陷")]),e._v(" "),v("p",[e._v("Webpack 的 Tree Shaking 逻辑停留在代码静态分析层面，只是浅显地判断：")]),e._v(" "),v("ul",[v("li",[e._v("模块导出变量是否被其它模块引用；")]),e._v(" "),v("li",[e._v("引用模块的主体代码中有没有出现这个变量。")])]),e._v(" "),v("p",[e._v("没有进一步，从语义上分析模块导出值是不是真的被有效使用。")]),e._v(" "),v("h2",{attrs:{id:"总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),v("p",[e._v("综上，Tree-Shaking 是一种只对 ESM 有效的 Dead Code Elimination 技术，它能够自动删除无效（没有被使用，且没有副作用）的模块导出变量，优化产物体积。不过，受限于 JavaScript 语言灵活性所带来的高度动态特性，Tree-Shaking 并不能完美删除所有无效的模块导出，需要我们在业务代码中遵循若干最佳实践规则，帮助 Tree-Shaking 更好地运行。")])])}),[],!1,null,null,null);_.default=i.exports}}]);